"use strict";(self.webpackChunk_irmos_source=self.webpackChunk_irmos_source||[]).push([[628],{"./node_modules/is-any-array/lib-esm/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{isAnyArray:()=>isAnyArray});const toString=Object.prototype.toString;function isAnyArray(value){const tag=toString.call(value);return tag.endsWith("Array]")&&!tag.includes("Big")}},"./node_modules/ml-array-rescale/lib-es6/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{default:()=>rescale});var lib_esm=__webpack_require__("./node_modules/is-any-array/lib-esm/index.js");function rescale(input){var output,options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!(0,lib_esm.isAnyArray)(input))throw new TypeError("input must be an array");if(0===input.length)throw new TypeError("input must not be empty");if(void 0!==options.output){if(!(0,lib_esm.isAnyArray)(options.output))throw new TypeError("output option must be an array if specified");output=options.output}else output=new Array(input.length);var currentMin=function min(input){var options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!(0,lib_esm.isAnyArray)(input))throw new TypeError("input must be an array");if(0===input.length)throw new TypeError("input must not be empty");var _options$fromIndex=options.fromIndex,fromIndex=void 0===_options$fromIndex?0:_options$fromIndex,_options$toIndex=options.toIndex,toIndex=void 0===_options$toIndex?input.length:_options$toIndex;if(fromIndex<0||fromIndex>=input.length||!Number.isInteger(fromIndex))throw new Error("fromIndex must be a positive integer smaller than length");if(toIndex<=fromIndex||toIndex>input.length||!Number.isInteger(toIndex))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var minValue=input[fromIndex],i=fromIndex+1;i<toIndex;i++)input[i]<minValue&&(minValue=input[i]);return minValue}(input),currentMax=function max(input){var options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!(0,lib_esm.isAnyArray)(input))throw new TypeError("input must be an array");if(0===input.length)throw new TypeError("input must not be empty");var _options$fromIndex=options.fromIndex,fromIndex=void 0===_options$fromIndex?0:_options$fromIndex,_options$toIndex=options.toIndex,toIndex=void 0===_options$toIndex?input.length:_options$toIndex;if(fromIndex<0||fromIndex>=input.length||!Number.isInteger(fromIndex))throw new Error("fromIndex must be a positive integer smaller than length");if(toIndex<=fromIndex||toIndex>input.length||!Number.isInteger(toIndex))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var maxValue=input[fromIndex],i=fromIndex+1;i<toIndex;i++)input[i]>maxValue&&(maxValue=input[i]);return maxValue}(input);if(currentMin===currentMax)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var _options$min=options.min,minValue=void 0===_options$min?options.autoMinMax?currentMin:0:_options$min,_options$max=options.max,maxValue=void 0===_options$max?options.autoMinMax?currentMax:1:_options$max;if(minValue>=maxValue)throw new RangeError("min option must be smaller than max option");for(var factor=(maxValue-minValue)/(currentMax-currentMin),i=0;i<input.length;i++)output[i]=(input[i]-currentMin)*factor+minValue;return output}},"./node_modules/ml-matrix/matrix.js":(__unused_webpack_module,exports,__webpack_require__)=>{var isAnyArray=__webpack_require__("./node_modules/is-any-array/lib-esm/index.js"),rescale=__webpack_require__("./node_modules/ml-array-rescale/lib-es6/index.js");const indent=" ".repeat(2),indentData=" ".repeat(4);function inspectMatrixWithOptions(matrix,options={}){const{maxRows=15,maxColumns=10,maxNumSize=8,padMinus="auto"}=options;return`${matrix.constructor.name} {\n${indent}[\n${indentData}${function inspectData(matrix,maxRows,maxColumns,maxNumSize,padMinus){const{rows,columns}=matrix,maxI=Math.min(rows,maxRows),maxJ=Math.min(columns,maxColumns),result=[];if("auto"===padMinus){padMinus=!1;loop:for(let i=0;i<maxI;i++)for(let j=0;j<maxJ;j++)if(matrix.get(i,j)<0){padMinus=!0;break loop}}for(let i=0;i<maxI;i++){let line=[];for(let j=0;j<maxJ;j++)line.push(formatNumber(matrix.get(i,j),maxNumSize,padMinus));result.push(`${line.join(" ")}`)}maxJ!==columns&&(result[result.length-1]+=` ... ${columns-maxColumns} more columns`);maxI!==rows&&result.push(`... ${rows-maxRows} more rows`);return result.join(`\n${indentData}`)}(matrix,maxRows,maxColumns,maxNumSize,padMinus)}\n${indent}]\n${indent}rows: ${matrix.rows}\n${indent}columns: ${matrix.columns}\n}`}function formatNumber(num,maxNumSize,padMinus){return(num>=0&&padMinus?` ${formatNumber2(num,maxNumSize-1)}`:formatNumber2(num,maxNumSize)).padEnd(maxNumSize)}function formatNumber2(num,len){let str=num.toString();if(str.length<=len)return str;let fix=num.toFixed(len);if(fix.length>len&&(fix=num.toFixed(Math.max(0,len-(fix.length-len)))),fix.length<=len&&!fix.startsWith("0.000")&&!fix.startsWith("-0.000"))return fix;let exp=num.toExponential(len);return exp.length>len&&(exp=num.toExponential(Math.max(0,len-(exp.length-len)))),exp.slice(0)}function checkRowIndex(matrix,index,outer){let max=outer?matrix.rows:matrix.rows-1;if(index<0||index>max)throw new RangeError("Row index out of range")}function checkColumnIndex(matrix,index,outer){let max=outer?matrix.columns:matrix.columns-1;if(index<0||index>max)throw new RangeError("Column index out of range")}function checkRowVector(matrix,vector){if(vector.to1DArray&&(vector=vector.to1DArray()),vector.length!==matrix.columns)throw new RangeError("vector size must be the same as the number of columns");return vector}function checkColumnVector(matrix,vector){if(vector.to1DArray&&(vector=vector.to1DArray()),vector.length!==matrix.rows)throw new RangeError("vector size must be the same as the number of rows");return vector}function checkRowIndices(matrix,rowIndices){if(!isAnyArray.isAnyArray(rowIndices))throw new TypeError("row indices must be an array");for(let i=0;i<rowIndices.length;i++)if(rowIndices[i]<0||rowIndices[i]>=matrix.rows)throw new RangeError("row indices are out of range")}function checkColumnIndices(matrix,columnIndices){if(!isAnyArray.isAnyArray(columnIndices))throw new TypeError("column indices must be an array");for(let i=0;i<columnIndices.length;i++)if(columnIndices[i]<0||columnIndices[i]>=matrix.columns)throw new RangeError("column indices are out of range")}function checkRange(matrix,startRow,endRow,startColumn,endColumn){if(5!==arguments.length)throw new RangeError("expected 4 arguments");if(checkNumber("startRow",startRow),checkNumber("endRow",endRow),checkNumber("startColumn",startColumn),checkNumber("endColumn",endColumn),startRow>endRow||startColumn>endColumn||startRow<0||startRow>=matrix.rows||endRow<0||endRow>=matrix.rows||startColumn<0||startColumn>=matrix.columns||endColumn<0||endColumn>=matrix.columns)throw new RangeError("Submatrix indices are out of range")}function newArray(length,value=0){let array=[];for(let i=0;i<length;i++)array.push(value);return array}function checkNumber(name,value){if("number"!=typeof value)throw new TypeError(`${name} must be a number`)}function checkNonEmpty(matrix){if(matrix.isEmpty())throw new Error("Empty matrix has no elements to index")}class AbstractMatrix{static from1DArray(newRows,newColumns,newData){if(newRows*newColumns!==newData.length)throw new RangeError("data length does not match given dimensions");let newMatrix=new Matrix(newRows,newColumns);for(let row=0;row<newRows;row++)for(let column=0;column<newColumns;column++)newMatrix.set(row,column,newData[row*newColumns+column]);return newMatrix}static rowVector(newData){let vector=new Matrix(1,newData.length);for(let i=0;i<newData.length;i++)vector.set(0,i,newData[i]);return vector}static columnVector(newData){let vector=new Matrix(newData.length,1);for(let i=0;i<newData.length;i++)vector.set(i,0,newData[i]);return vector}static zeros(rows,columns){return new Matrix(rows,columns)}static ones(rows,columns){return new Matrix(rows,columns).fill(1)}static rand(rows,columns,options={}){if("object"!=typeof options)throw new TypeError("options must be an object");const{random=Math.random}=options;let matrix=new Matrix(rows,columns);for(let i=0;i<rows;i++)for(let j=0;j<columns;j++)matrix.set(i,j,random());return matrix}static randInt(rows,columns,options={}){if("object"!=typeof options)throw new TypeError("options must be an object");const{min=0,max=1e3,random=Math.random}=options;if(!Number.isInteger(min))throw new TypeError("min must be an integer");if(!Number.isInteger(max))throw new TypeError("max must be an integer");if(min>=max)throw new RangeError("min must be smaller than max");let interval=max-min,matrix=new Matrix(rows,columns);for(let i=0;i<rows;i++)for(let j=0;j<columns;j++){let value=min+Math.round(random()*interval);matrix.set(i,j,value)}return matrix}static eye(rows,columns,value){void 0===columns&&(columns=rows),void 0===value&&(value=1);let min=Math.min(rows,columns),matrix=this.zeros(rows,columns);for(let i=0;i<min;i++)matrix.set(i,i,value);return matrix}static diag(data,rows,columns){let l=data.length;void 0===rows&&(rows=l),void 0===columns&&(columns=rows);let min=Math.min(l,rows,columns),matrix=this.zeros(rows,columns);for(let i=0;i<min;i++)matrix.set(i,i,data[i]);return matrix}static min(matrix1,matrix2){matrix1=this.checkMatrix(matrix1),matrix2=this.checkMatrix(matrix2);let rows=matrix1.rows,columns=matrix1.columns,result=new Matrix(rows,columns);for(let i=0;i<rows;i++)for(let j=0;j<columns;j++)result.set(i,j,Math.min(matrix1.get(i,j),matrix2.get(i,j)));return result}static max(matrix1,matrix2){matrix1=this.checkMatrix(matrix1),matrix2=this.checkMatrix(matrix2);let rows=matrix1.rows,columns=matrix1.columns,result=new this(rows,columns);for(let i=0;i<rows;i++)for(let j=0;j<columns;j++)result.set(i,j,Math.max(matrix1.get(i,j),matrix2.get(i,j)));return result}static checkMatrix(value){return AbstractMatrix.isMatrix(value)?value:new Matrix(value)}static isMatrix(value){return null!=value&&"Matrix"===value.klass}get size(){return this.rows*this.columns}apply(callback){if("function"!=typeof callback)throw new TypeError("callback must be a function");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)callback.call(this,i,j);return this}to1DArray(){let array=[];for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)array.push(this.get(i,j));return array}to2DArray(){let copy=[];for(let i=0;i<this.rows;i++){copy.push([]);for(let j=0;j<this.columns;j++)copy[i].push(this.get(i,j))}return copy}toJSON(){return this.to2DArray()}isRowVector(){return 1===this.rows}isColumnVector(){return 1===this.columns}isVector(){return 1===this.rows||1===this.columns}isSquare(){return this.rows===this.columns}isEmpty(){return 0===this.rows||0===this.columns}isSymmetric(){if(this.isSquare()){for(let i=0;i<this.rows;i++)for(let j=0;j<=i;j++)if(this.get(i,j)!==this.get(j,i))return!1;return!0}return!1}isDistance(){if(!this.isSymmetric())return!1;for(let i=0;i<this.rows;i++)if(0!==this.get(i,i))return!1;return!0}isEchelonForm(){let i=0,j=0,previousColumn=-1,isEchelonForm=!0,checked=!1;for(;i<this.rows&&isEchelonForm;){for(j=0,checked=!1;j<this.columns&&!1===checked;)0===this.get(i,j)?j++:1===this.get(i,j)&&j>previousColumn?(checked=!0,previousColumn=j):(isEchelonForm=!1,checked=!0);i++}return isEchelonForm}isReducedEchelonForm(){let i=0,j=0,previousColumn=-1,isReducedEchelonForm=!0,checked=!1;for(;i<this.rows&&isReducedEchelonForm;){for(j=0,checked=!1;j<this.columns&&!1===checked;)0===this.get(i,j)?j++:1===this.get(i,j)&&j>previousColumn?(checked=!0,previousColumn=j):(isReducedEchelonForm=!1,checked=!0);for(let k=j+1;k<this.rows;k++)0!==this.get(i,k)&&(isReducedEchelonForm=!1);i++}return isReducedEchelonForm}echelonForm(){let result=this.clone(),h=0,k=0;for(;h<result.rows&&k<result.columns;){let iMax=h;for(let i=h;i<result.rows;i++)result.get(i,k)>result.get(iMax,k)&&(iMax=i);if(0===result.get(iMax,k))k++;else{result.swapRows(h,iMax);let tmp=result.get(h,k);for(let j=k;j<result.columns;j++)result.set(h,j,result.get(h,j)/tmp);for(let i=h+1;i<result.rows;i++){let factor=result.get(i,k)/result.get(h,k);result.set(i,k,0);for(let j=k+1;j<result.columns;j++)result.set(i,j,result.get(i,j)-result.get(h,j)*factor)}h++,k++}}return result}reducedEchelonForm(){let result=this.echelonForm(),m=result.columns,n=result.rows,h=n-1;for(;h>=0;)if(0===result.maxRow(h))h--;else{let p=0,pivot=!1;for(;p<n&&!1===pivot;)1===result.get(h,p)?pivot=!0:p++;for(let i=0;i<h;i++){let factor=result.get(i,p);for(let j=p;j<m;j++){let tmp=result.get(i,j)-factor*result.get(h,j);result.set(i,j,tmp)}}h--}return result}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(options={}){if("object"!=typeof options)throw new TypeError("options must be an object");const{rows=1,columns=1}=options;if(!Number.isInteger(rows)||rows<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(columns)||columns<=0)throw new TypeError("columns must be a positive integer");let matrix=new Matrix(this.rows*rows,this.columns*columns);for(let i=0;i<rows;i++)for(let j=0;j<columns;j++)matrix.setSubMatrix(this,this.rows*i,this.columns*j);return matrix}fill(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,value);return this}neg(){return this.mulS(-1)}getRow(index){checkRowIndex(this,index);let row=[];for(let i=0;i<this.columns;i++)row.push(this.get(index,i));return row}getRowVector(index){return Matrix.rowVector(this.getRow(index))}setRow(index,array){checkRowIndex(this,index),array=checkRowVector(this,array);for(let i=0;i<this.columns;i++)this.set(index,i,array[i]);return this}swapRows(row1,row2){checkRowIndex(this,row1),checkRowIndex(this,row2);for(let i=0;i<this.columns;i++){let temp=this.get(row1,i);this.set(row1,i,this.get(row2,i)),this.set(row2,i,temp)}return this}getColumn(index){checkColumnIndex(this,index);let column=[];for(let i=0;i<this.rows;i++)column.push(this.get(i,index));return column}getColumnVector(index){return Matrix.columnVector(this.getColumn(index))}setColumn(index,array){checkColumnIndex(this,index),array=checkColumnVector(this,array);for(let i=0;i<this.rows;i++)this.set(i,index,array[i]);return this}swapColumns(column1,column2){checkColumnIndex(this,column1),checkColumnIndex(this,column2);for(let i=0;i<this.rows;i++){let temp=this.get(i,column1);this.set(i,column1,this.get(i,column2)),this.set(i,column2,temp)}return this}addRowVector(vector){vector=checkRowVector(this,vector);for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)+vector[j]);return this}subRowVector(vector){vector=checkRowVector(this,vector);for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)-vector[j]);return this}mulRowVector(vector){vector=checkRowVector(this,vector);for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)*vector[j]);return this}divRowVector(vector){vector=checkRowVector(this,vector);for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)/vector[j]);return this}addColumnVector(vector){vector=checkColumnVector(this,vector);for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)+vector[i]);return this}subColumnVector(vector){vector=checkColumnVector(this,vector);for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)-vector[i]);return this}mulColumnVector(vector){vector=checkColumnVector(this,vector);for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)*vector[i]);return this}divColumnVector(vector){vector=checkColumnVector(this,vector);for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)/vector[i]);return this}mulRow(index,value){checkRowIndex(this,index);for(let i=0;i<this.columns;i++)this.set(index,i,this.get(index,i)*value);return this}mulColumn(index,value){checkColumnIndex(this,index);for(let i=0;i<this.rows;i++)this.set(i,index,this.get(i,index)*value);return this}max(by){if(this.isEmpty())return NaN;switch(by){case"row":{const max=new Array(this.rows).fill(Number.NEGATIVE_INFINITY);for(let row=0;row<this.rows;row++)for(let column=0;column<this.columns;column++)this.get(row,column)>max[row]&&(max[row]=this.get(row,column));return max}case"column":{const max=new Array(this.columns).fill(Number.NEGATIVE_INFINITY);for(let row=0;row<this.rows;row++)for(let column=0;column<this.columns;column++)this.get(row,column)>max[column]&&(max[column]=this.get(row,column));return max}case void 0:{let max=this.get(0,0);for(let row=0;row<this.rows;row++)for(let column=0;column<this.columns;column++)this.get(row,column)>max&&(max=this.get(row,column));return max}default:throw new Error(`invalid option: ${by}`)}}maxIndex(){checkNonEmpty(this);let v=this.get(0,0),idx=[0,0];for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.get(i,j)>v&&(v=this.get(i,j),idx[0]=i,idx[1]=j);return idx}min(by){if(this.isEmpty())return NaN;switch(by){case"row":{const min=new Array(this.rows).fill(Number.POSITIVE_INFINITY);for(let row=0;row<this.rows;row++)for(let column=0;column<this.columns;column++)this.get(row,column)<min[row]&&(min[row]=this.get(row,column));return min}case"column":{const min=new Array(this.columns).fill(Number.POSITIVE_INFINITY);for(let row=0;row<this.rows;row++)for(let column=0;column<this.columns;column++)this.get(row,column)<min[column]&&(min[column]=this.get(row,column));return min}case void 0:{let min=this.get(0,0);for(let row=0;row<this.rows;row++)for(let column=0;column<this.columns;column++)this.get(row,column)<min&&(min=this.get(row,column));return min}default:throw new Error(`invalid option: ${by}`)}}minIndex(){checkNonEmpty(this);let v=this.get(0,0),idx=[0,0];for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.get(i,j)<v&&(v=this.get(i,j),idx[0]=i,idx[1]=j);return idx}maxRow(row){if(checkRowIndex(this,row),this.isEmpty())return NaN;let v=this.get(row,0);for(let i=1;i<this.columns;i++)this.get(row,i)>v&&(v=this.get(row,i));return v}maxRowIndex(row){checkRowIndex(this,row),checkNonEmpty(this);let v=this.get(row,0),idx=[row,0];for(let i=1;i<this.columns;i++)this.get(row,i)>v&&(v=this.get(row,i),idx[1]=i);return idx}minRow(row){if(checkRowIndex(this,row),this.isEmpty())return NaN;let v=this.get(row,0);for(let i=1;i<this.columns;i++)this.get(row,i)<v&&(v=this.get(row,i));return v}minRowIndex(row){checkRowIndex(this,row),checkNonEmpty(this);let v=this.get(row,0),idx=[row,0];for(let i=1;i<this.columns;i++)this.get(row,i)<v&&(v=this.get(row,i),idx[1]=i);return idx}maxColumn(column){if(checkColumnIndex(this,column),this.isEmpty())return NaN;let v=this.get(0,column);for(let i=1;i<this.rows;i++)this.get(i,column)>v&&(v=this.get(i,column));return v}maxColumnIndex(column){checkColumnIndex(this,column),checkNonEmpty(this);let v=this.get(0,column),idx=[0,column];for(let i=1;i<this.rows;i++)this.get(i,column)>v&&(v=this.get(i,column),idx[0]=i);return idx}minColumn(column){if(checkColumnIndex(this,column),this.isEmpty())return NaN;let v=this.get(0,column);for(let i=1;i<this.rows;i++)this.get(i,column)<v&&(v=this.get(i,column));return v}minColumnIndex(column){checkColumnIndex(this,column),checkNonEmpty(this);let v=this.get(0,column),idx=[0,column];for(let i=1;i<this.rows;i++)this.get(i,column)<v&&(v=this.get(i,column),idx[0]=i);return idx}diag(){let min=Math.min(this.rows,this.columns),diag=[];for(let i=0;i<min;i++)diag.push(this.get(i,i));return diag}norm(type="frobenius"){switch(type){case"max":return this.max();case"frobenius":return Math.sqrt(this.dot(this));default:throw new RangeError(`unknown norm type: ${type}`)}}cumulativeSum(){let sum=0;for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)sum+=this.get(i,j),this.set(i,j,sum);return this}dot(vector2){AbstractMatrix.isMatrix(vector2)&&(vector2=vector2.to1DArray());let vector1=this.to1DArray();if(vector1.length!==vector2.length)throw new RangeError("vectors do not have the same size");let dot=0;for(let i=0;i<vector1.length;i++)dot+=vector1[i]*vector2[i];return dot}mmul(other){other=Matrix.checkMatrix(other);let m=this.rows,n=this.columns,p=other.columns,result=new Matrix(m,p),Bcolj=new Float64Array(n);for(let j=0;j<p;j++){for(let k=0;k<n;k++)Bcolj[k]=other.get(k,j);for(let i=0;i<m;i++){let s=0;for(let k=0;k<n;k++)s+=this.get(i,k)*Bcolj[k];result.set(i,j,s)}}return result}mpow(scalar){if(!this.isSquare())throw new RangeError("Matrix must be square");if(!Number.isInteger(scalar)||scalar<0)throw new RangeError("Exponent must be a non-negative integer");let result=Matrix.eye(this.rows),bb=this;for(let e=scalar;e>=1;e/=2)1&e&&(result=result.mmul(bb)),bb=bb.mmul(bb);return result}strassen2x2(other){other=Matrix.checkMatrix(other);let result=new Matrix(2,2);const a11=this.get(0,0),b11=other.get(0,0),a12=this.get(0,1),b12=other.get(0,1),a21=this.get(1,0),b21=other.get(1,0),a22=this.get(1,1),b22=other.get(1,1),m1=(a11+a22)*(b11+b22),m2=(a21+a22)*b11,m3=a11*(b12-b22),m4=a22*(b21-b11),m5=(a11+a12)*b22,c00=m1+m4-m5+(a12-a22)*(b21+b22),c01=m3+m5,c10=m2+m4,c11=m1-m2+m3+(a21-a11)*(b11+b12);return result.set(0,0,c00),result.set(0,1,c01),result.set(1,0,c10),result.set(1,1,c11),result}strassen3x3(other){other=Matrix.checkMatrix(other);let result=new Matrix(3,3);const a00=this.get(0,0),a01=this.get(0,1),a02=this.get(0,2),a10=this.get(1,0),a11=this.get(1,1),a12=this.get(1,2),a20=this.get(2,0),a21=this.get(2,1),a22=this.get(2,2),b00=other.get(0,0),b01=other.get(0,1),b02=other.get(0,2),b10=other.get(1,0),b11=other.get(1,1),b12=other.get(1,2),b20=other.get(2,0),b21=other.get(2,1),b22=other.get(2,2),m2=(a00-a10)*(-b01+b11),m4=(-a00+a10+a11)*(b00-b01+b11),m5=(a10+a11)*(-b00+b01),m6=a00*b00,m7=(-a00+a20+a21)*(b00-b02+b12),m8=(-a00+a20)*(b02-b12),m9=(a20+a21)*(-b00+b02),m12=(-a02+a21+a22)*(b11+b20-b21),m13=(a02-a22)*(b11-b21),m14=a02*b20,m15=(a21+a22)*(-b20+b21),m16=(-a02+a11+a12)*(b12+b20-b22),m17=(a02-a12)*(b12-b22),m18=(a11+a12)*(-b20+b22),c00=m6+m14+a01*b10,c01=(a00+a01+a02-a10-a11-a21-a22)*b11+m4+m5+m6+m12+m14+m15,c02=m6+m7+m9+(a00+a01+a02-a11-a12-a20-a21)*b12+m14+m16+m18,c10=m2+a11*(-b00+b01+b10-b11-b12-b20+b22)+m4+m6+m14+m16+m17,c11=m2+m4+m5+m6+a12*b21,c12=m14+m16+m17+m18+a10*b02,c20=m6+m7+m8+a21*(-b00+b02+b10-b11-b12-b20+b21)+m12+m13+m14,c21=m12+m13+m14+m15+a20*b01,c22=m6+m7+m8+m9+a22*b22;return result.set(0,0,c00),result.set(0,1,c01),result.set(0,2,c02),result.set(1,0,c10),result.set(1,1,c11),result.set(1,2,c12),result.set(2,0,c20),result.set(2,1,c21),result.set(2,2,c22),result}mmulStrassen(y){y=Matrix.checkMatrix(y);let x=this.clone(),r1=x.rows,c1=x.columns,r2=y.rows,c2=y.columns;function embed(mat,rows,cols){let r=mat.rows,c=mat.columns;if(r===rows&&c===cols)return mat;{let resultat=AbstractMatrix.zeros(rows,cols);return resultat=resultat.setSubMatrix(mat,0,0),resultat}}c1!==r2&&console.warn(`Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`);let r=Math.max(r1,r2),c=Math.max(c1,c2);return x=embed(x,r,c),function blockMult(a,b,rows,cols){if(rows<=512||cols<=512)return a.mmul(b);rows%2==1&&cols%2==1?(a=embed(a,rows+1,cols+1),b=embed(b,rows+1,cols+1)):rows%2==1?(a=embed(a,rows+1,cols),b=embed(b,rows+1,cols)):cols%2==1&&(a=embed(a,rows,cols+1),b=embed(b,rows,cols+1));let halfRows=parseInt(a.rows/2,10),halfCols=parseInt(a.columns/2,10),a11=a.subMatrix(0,halfRows-1,0,halfCols-1),b11=b.subMatrix(0,halfRows-1,0,halfCols-1),a12=a.subMatrix(0,halfRows-1,halfCols,a.columns-1),b12=b.subMatrix(0,halfRows-1,halfCols,b.columns-1),a21=a.subMatrix(halfRows,a.rows-1,0,halfCols-1),b21=b.subMatrix(halfRows,b.rows-1,0,halfCols-1),a22=a.subMatrix(halfRows,a.rows-1,halfCols,a.columns-1),b22=b.subMatrix(halfRows,b.rows-1,halfCols,b.columns-1),m1=blockMult(AbstractMatrix.add(a11,a22),AbstractMatrix.add(b11,b22),halfRows,halfCols),m2=blockMult(AbstractMatrix.add(a21,a22),b11,halfRows,halfCols),m3=blockMult(a11,AbstractMatrix.sub(b12,b22),halfRows,halfCols),m4=blockMult(a22,AbstractMatrix.sub(b21,b11),halfRows,halfCols),m5=blockMult(AbstractMatrix.add(a11,a12),b22,halfRows,halfCols),m6=blockMult(AbstractMatrix.sub(a21,a11),AbstractMatrix.add(b11,b12),halfRows,halfCols),m7=blockMult(AbstractMatrix.sub(a12,a22),AbstractMatrix.add(b21,b22),halfRows,halfCols),c11=AbstractMatrix.add(m1,m4);c11.sub(m5),c11.add(m7);let c12=AbstractMatrix.add(m3,m5),c21=AbstractMatrix.add(m2,m4),c22=AbstractMatrix.sub(m1,m2);c22.add(m3),c22.add(m6);let result=AbstractMatrix.zeros(2*c11.rows,2*c11.columns);return result=result.setSubMatrix(c11,0,0),result=result.setSubMatrix(c12,c11.rows,0),result=result.setSubMatrix(c21,0,c11.columns),result=result.setSubMatrix(c22,c11.rows,c11.columns),result.subMatrix(0,rows-1,0,cols-1)}(x,y=embed(y,r,c),r,c)}scaleRows(options={}){if("object"!=typeof options)throw new TypeError("options must be an object");const{min=0,max=1}=options;if(!Number.isFinite(min))throw new TypeError("min must be a number");if(!Number.isFinite(max))throw new TypeError("max must be a number");if(min>=max)throw new RangeError("min must be smaller than max");let newMatrix=new Matrix(this.rows,this.columns);for(let i=0;i<this.rows;i++){const row=this.getRow(i);row.length>0&&rescale(row,{min,max,output:row}),newMatrix.setRow(i,row)}return newMatrix}scaleColumns(options={}){if("object"!=typeof options)throw new TypeError("options must be an object");const{min=0,max=1}=options;if(!Number.isFinite(min))throw new TypeError("min must be a number");if(!Number.isFinite(max))throw new TypeError("max must be a number");if(min>=max)throw new RangeError("min must be smaller than max");let newMatrix=new Matrix(this.rows,this.columns);for(let i=0;i<this.columns;i++){const column=this.getColumn(i);column.length&&rescale(column,{min,max,output:column}),newMatrix.setColumn(i,column)}return newMatrix}flipRows(){const middle=Math.ceil(this.columns/2);for(let i=0;i<this.rows;i++)for(let j=0;j<middle;j++){let first=this.get(i,j),last=this.get(i,this.columns-1-j);this.set(i,j,last),this.set(i,this.columns-1-j,first)}return this}flipColumns(){const middle=Math.ceil(this.rows/2);for(let j=0;j<this.columns;j++)for(let i=0;i<middle;i++){let first=this.get(i,j),last=this.get(this.rows-1-i,j);this.set(i,j,last),this.set(this.rows-1-i,j,first)}return this}kroneckerProduct(other){other=Matrix.checkMatrix(other);let m=this.rows,n=this.columns,p=other.rows,q=other.columns,result=new Matrix(m*p,n*q);for(let i=0;i<m;i++)for(let j=0;j<n;j++)for(let k=0;k<p;k++)for(let l=0;l<q;l++)result.set(p*i+k,q*j+l,this.get(i,j)*other.get(k,l));return result}kroneckerSum(other){if(other=Matrix.checkMatrix(other),!this.isSquare()||!other.isSquare())throw new Error("Kronecker Sum needs two Square Matrices");let m=this.rows,n=other.rows,AxI=this.kroneckerProduct(Matrix.eye(n,n)),IxB=Matrix.eye(m,m).kroneckerProduct(other);return AxI.add(IxB)}transpose(){let result=new Matrix(this.columns,this.rows);for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)result.set(j,i,this.get(i,j));return result}sortRows(compareFunction=compareNumbers){for(let i=0;i<this.rows;i++)this.setRow(i,this.getRow(i).sort(compareFunction));return this}sortColumns(compareFunction=compareNumbers){for(let i=0;i<this.columns;i++)this.setColumn(i,this.getColumn(i).sort(compareFunction));return this}subMatrix(startRow,endRow,startColumn,endColumn){checkRange(this,startRow,endRow,startColumn,endColumn);let newMatrix=new Matrix(endRow-startRow+1,endColumn-startColumn+1);for(let i=startRow;i<=endRow;i++)for(let j=startColumn;j<=endColumn;j++)newMatrix.set(i-startRow,j-startColumn,this.get(i,j));return newMatrix}subMatrixRow(indices,startColumn,endColumn){if(void 0===startColumn&&(startColumn=0),void 0===endColumn&&(endColumn=this.columns-1),startColumn>endColumn||startColumn<0||startColumn>=this.columns||endColumn<0||endColumn>=this.columns)throw new RangeError("Argument out of range");let newMatrix=new Matrix(indices.length,endColumn-startColumn+1);for(let i=0;i<indices.length;i++)for(let j=startColumn;j<=endColumn;j++){if(indices[i]<0||indices[i]>=this.rows)throw new RangeError(`Row index out of range: ${indices[i]}`);newMatrix.set(i,j-startColumn,this.get(indices[i],j))}return newMatrix}subMatrixColumn(indices,startRow,endRow){if(void 0===startRow&&(startRow=0),void 0===endRow&&(endRow=this.rows-1),startRow>endRow||startRow<0||startRow>=this.rows||endRow<0||endRow>=this.rows)throw new RangeError("Argument out of range");let newMatrix=new Matrix(endRow-startRow+1,indices.length);for(let i=0;i<indices.length;i++)for(let j=startRow;j<=endRow;j++){if(indices[i]<0||indices[i]>=this.columns)throw new RangeError(`Column index out of range: ${indices[i]}`);newMatrix.set(j-startRow,i,this.get(j,indices[i]))}return newMatrix}setSubMatrix(matrix,startRow,startColumn){if((matrix=Matrix.checkMatrix(matrix)).isEmpty())return this;checkRange(this,startRow,startRow+matrix.rows-1,startColumn,startColumn+matrix.columns-1);for(let i=0;i<matrix.rows;i++)for(let j=0;j<matrix.columns;j++)this.set(startRow+i,startColumn+j,matrix.get(i,j));return this}selection(rowIndices,columnIndices){checkRowIndices(this,rowIndices),checkColumnIndices(this,columnIndices);let newMatrix=new Matrix(rowIndices.length,columnIndices.length);for(let i=0;i<rowIndices.length;i++){let rowIndex=rowIndices[i];for(let j=0;j<columnIndices.length;j++){let columnIndex=columnIndices[j];newMatrix.set(i,j,this.get(rowIndex,columnIndex))}}return newMatrix}trace(){let min=Math.min(this.rows,this.columns),trace=0;for(let i=0;i<min;i++)trace+=this.get(i,i);return trace}clone(){return this.constructor.copy(this,new Matrix(this.rows,this.columns))}static copy(from,to){for(const[row,column,value]of from.entries())to.set(row,column,value);return to}sum(by){switch(by){case"row":return function sumByRow(matrix){let sum=newArray(matrix.rows);for(let i=0;i<matrix.rows;++i)for(let j=0;j<matrix.columns;++j)sum[i]+=matrix.get(i,j);return sum}(this);case"column":return function sumByColumn(matrix){let sum=newArray(matrix.columns);for(let i=0;i<matrix.rows;++i)for(let j=0;j<matrix.columns;++j)sum[j]+=matrix.get(i,j);return sum}(this);case void 0:return function sumAll(matrix){let v=0;for(let i=0;i<matrix.rows;i++)for(let j=0;j<matrix.columns;j++)v+=matrix.get(i,j);return v}(this);default:throw new Error(`invalid option: ${by}`)}}product(by){switch(by){case"row":return function productByRow(matrix){let sum=newArray(matrix.rows,1);for(let i=0;i<matrix.rows;++i)for(let j=0;j<matrix.columns;++j)sum[i]*=matrix.get(i,j);return sum}(this);case"column":return function productByColumn(matrix){let sum=newArray(matrix.columns,1);for(let i=0;i<matrix.rows;++i)for(let j=0;j<matrix.columns;++j)sum[j]*=matrix.get(i,j);return sum}(this);case void 0:return function productAll(matrix){let v=1;for(let i=0;i<matrix.rows;i++)for(let j=0;j<matrix.columns;j++)v*=matrix.get(i,j);return v}(this);default:throw new Error(`invalid option: ${by}`)}}mean(by){const sum=this.sum(by);switch(by){case"row":for(let i=0;i<this.rows;i++)sum[i]/=this.columns;return sum;case"column":for(let i=0;i<this.columns;i++)sum[i]/=this.rows;return sum;case void 0:return sum/this.size;default:throw new Error(`invalid option: ${by}`)}}variance(by,options={}){if("object"==typeof by&&(options=by,by=void 0),"object"!=typeof options)throw new TypeError("options must be an object");const{unbiased=!0,mean=this.mean(by)}=options;if("boolean"!=typeof unbiased)throw new TypeError("unbiased must be a boolean");switch(by){case"row":if(!isAnyArray.isAnyArray(mean))throw new TypeError("mean must be an array");return function varianceByRow(matrix,unbiased,mean){const rows=matrix.rows,cols=matrix.columns,variance=[];for(let i=0;i<rows;i++){let sum1=0,sum2=0,x=0;for(let j=0;j<cols;j++)x=matrix.get(i,j)-mean[i],sum1+=x,sum2+=x*x;unbiased?variance.push((sum2-sum1*sum1/cols)/(cols-1)):variance.push((sum2-sum1*sum1/cols)/cols)}return variance}(this,unbiased,mean);case"column":if(!isAnyArray.isAnyArray(mean))throw new TypeError("mean must be an array");return function varianceByColumn(matrix,unbiased,mean){const rows=matrix.rows,cols=matrix.columns,variance=[];for(let j=0;j<cols;j++){let sum1=0,sum2=0,x=0;for(let i=0;i<rows;i++)x=matrix.get(i,j)-mean[j],sum1+=x,sum2+=x*x;unbiased?variance.push((sum2-sum1*sum1/rows)/(rows-1)):variance.push((sum2-sum1*sum1/rows)/rows)}return variance}(this,unbiased,mean);case void 0:if("number"!=typeof mean)throw new TypeError("mean must be a number");return function varianceAll(matrix,unbiased,mean){const rows=matrix.rows,cols=matrix.columns,size=rows*cols;let sum1=0,sum2=0,x=0;for(let i=0;i<rows;i++)for(let j=0;j<cols;j++)x=matrix.get(i,j)-mean,sum1+=x,sum2+=x*x;return unbiased?(sum2-sum1*sum1/size)/(size-1):(sum2-sum1*sum1/size)/size}(this,unbiased,mean);default:throw new Error(`invalid option: ${by}`)}}standardDeviation(by,options){"object"==typeof by&&(options=by,by=void 0);const variance=this.variance(by,options);if(void 0===by)return Math.sqrt(variance);for(let i=0;i<variance.length;i++)variance[i]=Math.sqrt(variance[i]);return variance}center(by,options={}){if("object"==typeof by&&(options=by,by=void 0),"object"!=typeof options)throw new TypeError("options must be an object");const{center=this.mean(by)}=options;switch(by){case"row":if(!isAnyArray.isAnyArray(center))throw new TypeError("center must be an array");return function centerByRow(matrix,mean){for(let i=0;i<matrix.rows;i++)for(let j=0;j<matrix.columns;j++)matrix.set(i,j,matrix.get(i,j)-mean[i])}(this,center),this;case"column":if(!isAnyArray.isAnyArray(center))throw new TypeError("center must be an array");return function centerByColumn(matrix,mean){for(let i=0;i<matrix.rows;i++)for(let j=0;j<matrix.columns;j++)matrix.set(i,j,matrix.get(i,j)-mean[j])}(this,center),this;case void 0:if("number"!=typeof center)throw new TypeError("center must be a number");return function centerAll(matrix,mean){for(let i=0;i<matrix.rows;i++)for(let j=0;j<matrix.columns;j++)matrix.set(i,j,matrix.get(i,j)-mean)}(this,center),this;default:throw new Error(`invalid option: ${by}`)}}scale(by,options={}){if("object"==typeof by&&(options=by,by=void 0),"object"!=typeof options)throw new TypeError("options must be an object");let scale=options.scale;switch(by){case"row":if(void 0===scale)scale=function getScaleByRow(matrix){const scale=[];for(let i=0;i<matrix.rows;i++){let sum=0;for(let j=0;j<matrix.columns;j++)sum+=matrix.get(i,j)**2/(matrix.columns-1);scale.push(Math.sqrt(sum))}return scale}(this);else if(!isAnyArray.isAnyArray(scale))throw new TypeError("scale must be an array");return function scaleByRow(matrix,scale){for(let i=0;i<matrix.rows;i++)for(let j=0;j<matrix.columns;j++)matrix.set(i,j,matrix.get(i,j)/scale[i])}(this,scale),this;case"column":if(void 0===scale)scale=function getScaleByColumn(matrix){const scale=[];for(let j=0;j<matrix.columns;j++){let sum=0;for(let i=0;i<matrix.rows;i++)sum+=matrix.get(i,j)**2/(matrix.rows-1);scale.push(Math.sqrt(sum))}return scale}(this);else if(!isAnyArray.isAnyArray(scale))throw new TypeError("scale must be an array");return function scaleByColumn(matrix,scale){for(let i=0;i<matrix.rows;i++)for(let j=0;j<matrix.columns;j++)matrix.set(i,j,matrix.get(i,j)/scale[j])}(this,scale),this;case void 0:if(void 0===scale)scale=function getScaleAll(matrix){const divider=matrix.size-1;let sum=0;for(let j=0;j<matrix.columns;j++)for(let i=0;i<matrix.rows;i++)sum+=matrix.get(i,j)**2/divider;return Math.sqrt(sum)}(this);else if("number"!=typeof scale)throw new TypeError("scale must be a number");return function scaleAll(matrix,scale){for(let i=0;i<matrix.rows;i++)for(let j=0;j<matrix.columns;j++)matrix.set(i,j,matrix.get(i,j)/scale)}(this,scale),this;default:throw new Error(`invalid option: ${by}`)}}toString(options){return inspectMatrixWithOptions(this,options)}[Symbol.iterator](){return this.entries()}*entries(){for(let row=0;row<this.rows;row++)for(let col=0;col<this.columns;col++)yield[row,col,this.get(row,col)]}*values(){for(let row=0;row<this.rows;row++)for(let col=0;col<this.columns;col++)yield this.get(row,col)}}function compareNumbers(a,b){return a-b}AbstractMatrix.prototype.klass="Matrix","undefined"!=typeof Symbol&&(AbstractMatrix.prototype[Symbol.for("nodejs.util.inspect.custom")]=function inspectMatrix(){return inspectMatrixWithOptions(this)}),AbstractMatrix.random=AbstractMatrix.rand,AbstractMatrix.randomInt=AbstractMatrix.randInt,AbstractMatrix.diagonal=AbstractMatrix.diag,AbstractMatrix.prototype.diagonal=AbstractMatrix.prototype.diag,AbstractMatrix.identity=AbstractMatrix.eye,AbstractMatrix.prototype.negate=AbstractMatrix.prototype.neg,AbstractMatrix.prototype.tensorProduct=AbstractMatrix.prototype.kroneckerProduct;class Matrix extends AbstractMatrix{data;#initData(nRows,nColumns){if(this.data=[],!(Number.isInteger(nColumns)&&nColumns>=0))throw new TypeError("nColumns must be a positive integer");for(let i=0;i<nRows;i++)this.data.push(new Float64Array(nColumns));this.rows=nRows,this.columns=nColumns}constructor(nRows,nColumns){if(super(),Matrix.isMatrix(nRows))this.#initData(nRows.rows,nRows.columns),Matrix.copy(nRows,this);else if(Number.isInteger(nRows)&&nRows>=0)this.#initData(nRows,nColumns);else{if(!isAnyArray.isAnyArray(nRows))throw new TypeError("First argument must be a positive number or an array");{const arrayData=nRows;if("number"!=typeof(nColumns=(nRows=arrayData.length)?arrayData[0].length:0))throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let i=0;i<nRows;i++){if(arrayData[i].length!==nColumns)throw new RangeError("Inconsistent array dimensions");if(!arrayData[i].every((element=>"number"==typeof element)))throw new TypeError("Input data contains non-numeric values");this.data.push(Float64Array.from(arrayData[i]))}this.rows=nRows,this.columns=nColumns}}}set(rowIndex,columnIndex,value){return this.data[rowIndex][columnIndex]=value,this}get(rowIndex,columnIndex){return this.data[rowIndex][columnIndex]}removeRow(index){return checkRowIndex(this,index),this.data.splice(index,1),this.rows-=1,this}addRow(index,array){return void 0===array&&(array=index,index=this.rows),checkRowIndex(this,index,!0),array=Float64Array.from(checkRowVector(this,array)),this.data.splice(index,0,array),this.rows+=1,this}removeColumn(index){checkColumnIndex(this,index);for(let i=0;i<this.rows;i++){const newRow=new Float64Array(this.columns-1);for(let j=0;j<index;j++)newRow[j]=this.data[i][j];for(let j=index+1;j<this.columns;j++)newRow[j-1]=this.data[i][j];this.data[i]=newRow}return this.columns-=1,this}addColumn(index,array){void 0===array&&(array=index,index=this.columns),checkColumnIndex(this,index,!0),array=checkColumnVector(this,array);for(let i=0;i<this.rows;i++){const newRow=new Float64Array(this.columns+1);let j=0;for(;j<index;j++)newRow[j]=this.data[i][j];for(newRow[j++]=array[i];j<this.columns+1;j++)newRow[j]=this.data[i][j-1];this.data[i]=newRow}return this.columns+=1,this}}!function installMathOperations(AbstractMatrix,Matrix){AbstractMatrix.prototype.add=function add(value){return"number"==typeof value?this.addS(value):this.addM(value)},AbstractMatrix.prototype.addS=function addS(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)+value);return this},AbstractMatrix.prototype.addM=function addM(matrix){if(matrix=Matrix.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)+matrix.get(i,j));return this},AbstractMatrix.add=function add(matrix,value){return new Matrix(matrix).add(value)},AbstractMatrix.prototype.sub=function sub(value){return"number"==typeof value?this.subS(value):this.subM(value)},AbstractMatrix.prototype.subS=function subS(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)-value);return this},AbstractMatrix.prototype.subM=function subM(matrix){if(matrix=Matrix.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)-matrix.get(i,j));return this},AbstractMatrix.sub=function sub(matrix,value){return new Matrix(matrix).sub(value)},AbstractMatrix.prototype.subtract=AbstractMatrix.prototype.sub,AbstractMatrix.prototype.subtractS=AbstractMatrix.prototype.subS,AbstractMatrix.prototype.subtractM=AbstractMatrix.prototype.subM,AbstractMatrix.subtract=AbstractMatrix.sub,AbstractMatrix.prototype.mul=function mul(value){return"number"==typeof value?this.mulS(value):this.mulM(value)},AbstractMatrix.prototype.mulS=function mulS(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)*value);return this},AbstractMatrix.prototype.mulM=function mulM(matrix){if(matrix=Matrix.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)*matrix.get(i,j));return this},AbstractMatrix.mul=function mul(matrix,value){return new Matrix(matrix).mul(value)},AbstractMatrix.prototype.multiply=AbstractMatrix.prototype.mul,AbstractMatrix.prototype.multiplyS=AbstractMatrix.prototype.mulS,AbstractMatrix.prototype.multiplyM=AbstractMatrix.prototype.mulM,AbstractMatrix.multiply=AbstractMatrix.mul,AbstractMatrix.prototype.div=function div(value){return"number"==typeof value?this.divS(value):this.divM(value)},AbstractMatrix.prototype.divS=function divS(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)/value);return this},AbstractMatrix.prototype.divM=function divM(matrix){if(matrix=Matrix.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)/matrix.get(i,j));return this},AbstractMatrix.div=function div(matrix,value){return new Matrix(matrix).div(value)},AbstractMatrix.prototype.divide=AbstractMatrix.prototype.div,AbstractMatrix.prototype.divideS=AbstractMatrix.prototype.divS,AbstractMatrix.prototype.divideM=AbstractMatrix.prototype.divM,AbstractMatrix.divide=AbstractMatrix.div,AbstractMatrix.prototype.mod=function mod(value){return"number"==typeof value?this.modS(value):this.modM(value)},AbstractMatrix.prototype.modS=function modS(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)%value);return this},AbstractMatrix.prototype.modM=function modM(matrix){if(matrix=Matrix.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)%matrix.get(i,j));return this},AbstractMatrix.mod=function mod(matrix,value){return new Matrix(matrix).mod(value)},AbstractMatrix.prototype.modulus=AbstractMatrix.prototype.mod,AbstractMatrix.prototype.modulusS=AbstractMatrix.prototype.modS,AbstractMatrix.prototype.modulusM=AbstractMatrix.prototype.modM,AbstractMatrix.modulus=AbstractMatrix.mod,AbstractMatrix.prototype.and=function and(value){return"number"==typeof value?this.andS(value):this.andM(value)},AbstractMatrix.prototype.andS=function andS(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)&value);return this},AbstractMatrix.prototype.andM=function andM(matrix){if(matrix=Matrix.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)&matrix.get(i,j));return this},AbstractMatrix.and=function and(matrix,value){return new Matrix(matrix).and(value)},AbstractMatrix.prototype.or=function or(value){return"number"==typeof value?this.orS(value):this.orM(value)},AbstractMatrix.prototype.orS=function orS(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)|value);return this},AbstractMatrix.prototype.orM=function orM(matrix){if(matrix=Matrix.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)|matrix.get(i,j));return this},AbstractMatrix.or=function or(matrix,value){return new Matrix(matrix).or(value)},AbstractMatrix.prototype.xor=function xor(value){return"number"==typeof value?this.xorS(value):this.xorM(value)},AbstractMatrix.prototype.xorS=function xorS(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)^value);return this},AbstractMatrix.prototype.xorM=function xorM(matrix){if(matrix=Matrix.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)^matrix.get(i,j));return this},AbstractMatrix.xor=function xor(matrix,value){return new Matrix(matrix).xor(value)},AbstractMatrix.prototype.leftShift=function leftShift(value){return"number"==typeof value?this.leftShiftS(value):this.leftShiftM(value)},AbstractMatrix.prototype.leftShiftS=function leftShiftS(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)<<value);return this},AbstractMatrix.prototype.leftShiftM=function leftShiftM(matrix){if(matrix=Matrix.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)<<matrix.get(i,j));return this},AbstractMatrix.leftShift=function leftShift(matrix,value){return new Matrix(matrix).leftShift(value)},AbstractMatrix.prototype.signPropagatingRightShift=function signPropagatingRightShift(value){return"number"==typeof value?this.signPropagatingRightShiftS(value):this.signPropagatingRightShiftM(value)},AbstractMatrix.prototype.signPropagatingRightShiftS=function signPropagatingRightShiftS(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)>>value);return this},AbstractMatrix.prototype.signPropagatingRightShiftM=function signPropagatingRightShiftM(matrix){if(matrix=Matrix.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)>>matrix.get(i,j));return this},AbstractMatrix.signPropagatingRightShift=function signPropagatingRightShift(matrix,value){return new Matrix(matrix).signPropagatingRightShift(value)},AbstractMatrix.prototype.rightShift=function rightShift(value){return"number"==typeof value?this.rightShiftS(value):this.rightShiftM(value)},AbstractMatrix.prototype.rightShiftS=function rightShiftS(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)>>>value);return this},AbstractMatrix.prototype.rightShiftM=function rightShiftM(matrix){if(matrix=Matrix.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)>>>matrix.get(i,j));return this},AbstractMatrix.rightShift=function rightShift(matrix,value){return new Matrix(matrix).rightShift(value)},AbstractMatrix.prototype.zeroFillRightShift=AbstractMatrix.prototype.rightShift,AbstractMatrix.prototype.zeroFillRightShiftS=AbstractMatrix.prototype.rightShiftS,AbstractMatrix.prototype.zeroFillRightShiftM=AbstractMatrix.prototype.rightShiftM,AbstractMatrix.zeroFillRightShift=AbstractMatrix.rightShift,AbstractMatrix.prototype.not=function not(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,~this.get(i,j));return this},AbstractMatrix.not=function not(matrix){return new Matrix(matrix).not()},AbstractMatrix.prototype.abs=function abs(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.abs(this.get(i,j)));return this},AbstractMatrix.abs=function abs(matrix){return new Matrix(matrix).abs()},AbstractMatrix.prototype.acos=function acos(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.acos(this.get(i,j)));return this},AbstractMatrix.acos=function acos(matrix){return new Matrix(matrix).acos()},AbstractMatrix.prototype.acosh=function acosh(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.acosh(this.get(i,j)));return this},AbstractMatrix.acosh=function acosh(matrix){return new Matrix(matrix).acosh()},AbstractMatrix.prototype.asin=function asin(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.asin(this.get(i,j)));return this},AbstractMatrix.asin=function asin(matrix){return new Matrix(matrix).asin()},AbstractMatrix.prototype.asinh=function asinh(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.asinh(this.get(i,j)));return this},AbstractMatrix.asinh=function asinh(matrix){return new Matrix(matrix).asinh()},AbstractMatrix.prototype.atan=function atan(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.atan(this.get(i,j)));return this},AbstractMatrix.atan=function atan(matrix){return new Matrix(matrix).atan()},AbstractMatrix.prototype.atanh=function atanh(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.atanh(this.get(i,j)));return this},AbstractMatrix.atanh=function atanh(matrix){return new Matrix(matrix).atanh()},AbstractMatrix.prototype.cbrt=function cbrt(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.cbrt(this.get(i,j)));return this},AbstractMatrix.cbrt=function cbrt(matrix){return new Matrix(matrix).cbrt()},AbstractMatrix.prototype.ceil=function ceil(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.ceil(this.get(i,j)));return this},AbstractMatrix.ceil=function ceil(matrix){return new Matrix(matrix).ceil()},AbstractMatrix.prototype.clz32=function clz32(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.clz32(this.get(i,j)));return this},AbstractMatrix.clz32=function clz32(matrix){return new Matrix(matrix).clz32()},AbstractMatrix.prototype.cos=function cos(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.cos(this.get(i,j)));return this},AbstractMatrix.cos=function cos(matrix){return new Matrix(matrix).cos()},AbstractMatrix.prototype.cosh=function cosh(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.cosh(this.get(i,j)));return this},AbstractMatrix.cosh=function cosh(matrix){return new Matrix(matrix).cosh()},AbstractMatrix.prototype.exp=function exp(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.exp(this.get(i,j)));return this},AbstractMatrix.exp=function exp(matrix){return new Matrix(matrix).exp()},AbstractMatrix.prototype.expm1=function expm1(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.expm1(this.get(i,j)));return this},AbstractMatrix.expm1=function expm1(matrix){return new Matrix(matrix).expm1()},AbstractMatrix.prototype.floor=function floor(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.floor(this.get(i,j)));return this},AbstractMatrix.floor=function floor(matrix){return new Matrix(matrix).floor()},AbstractMatrix.prototype.fround=function fround(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.fround(this.get(i,j)));return this},AbstractMatrix.fround=function fround(matrix){return new Matrix(matrix).fround()},AbstractMatrix.prototype.log=function log(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.log(this.get(i,j)));return this},AbstractMatrix.log=function log(matrix){return new Matrix(matrix).log()},AbstractMatrix.prototype.log1p=function log1p(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.log1p(this.get(i,j)));return this},AbstractMatrix.log1p=function log1p(matrix){return new Matrix(matrix).log1p()},AbstractMatrix.prototype.log10=function log10(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.log10(this.get(i,j)));return this},AbstractMatrix.log10=function log10(matrix){return new Matrix(matrix).log10()},AbstractMatrix.prototype.log2=function log2(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.log2(this.get(i,j)));return this},AbstractMatrix.log2=function log2(matrix){return new Matrix(matrix).log2()},AbstractMatrix.prototype.round=function round(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.round(this.get(i,j)));return this},AbstractMatrix.round=function round(matrix){return new Matrix(matrix).round()},AbstractMatrix.prototype.sign=function sign(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.sign(this.get(i,j)));return this},AbstractMatrix.sign=function sign(matrix){return new Matrix(matrix).sign()},AbstractMatrix.prototype.sin=function sin(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.sin(this.get(i,j)));return this},AbstractMatrix.sin=function sin(matrix){return new Matrix(matrix).sin()},AbstractMatrix.prototype.sinh=function sinh(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.sinh(this.get(i,j)));return this},AbstractMatrix.sinh=function sinh(matrix){return new Matrix(matrix).sinh()},AbstractMatrix.prototype.sqrt=function sqrt(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.sqrt(this.get(i,j)));return this},AbstractMatrix.sqrt=function sqrt(matrix){return new Matrix(matrix).sqrt()},AbstractMatrix.prototype.tan=function tan(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.tan(this.get(i,j)));return this},AbstractMatrix.tan=function tan(matrix){return new Matrix(matrix).tan()},AbstractMatrix.prototype.tanh=function tanh(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.tanh(this.get(i,j)));return this},AbstractMatrix.tanh=function tanh(matrix){return new Matrix(matrix).tanh()},AbstractMatrix.prototype.trunc=function trunc(){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,Math.trunc(this.get(i,j)));return this},AbstractMatrix.trunc=function trunc(matrix){return new Matrix(matrix).trunc()},AbstractMatrix.pow=function pow(matrix,arg0){return new Matrix(matrix).pow(arg0)},AbstractMatrix.prototype.pow=function pow(value){return"number"==typeof value?this.powS(value):this.powM(value)},AbstractMatrix.prototype.powS=function powS(value){for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)**value);return this},AbstractMatrix.prototype.powM=function powM(matrix){if(matrix=Matrix.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let j=0;j<this.columns;j++)this.set(i,j,this.get(i,j)**matrix.get(i,j));return this}}(AbstractMatrix,Matrix);class SymmetricMatrix extends AbstractMatrix{#matrix;get size(){return this.#matrix.size}get rows(){return this.#matrix.rows}get columns(){return this.#matrix.columns}get diagonalSize(){return this.rows}static isSymmetricMatrix(value){return Matrix.isMatrix(value)&&"SymmetricMatrix"===value.klassType}static zeros(diagonalSize){return new this(diagonalSize)}static ones(diagonalSize){return new this(diagonalSize).fill(1)}constructor(diagonalSize){if(super(),Matrix.isMatrix(diagonalSize)){if(!diagonalSize.isSymmetric())throw new TypeError("not symmetric data");this.#matrix=Matrix.copy(diagonalSize,new Matrix(diagonalSize.rows,diagonalSize.rows))}else if(Number.isInteger(diagonalSize)&&diagonalSize>=0)this.#matrix=new Matrix(diagonalSize,diagonalSize);else if(this.#matrix=new Matrix(diagonalSize),!this.isSymmetric())throw new TypeError("not symmetric data")}clone(){const matrix=new SymmetricMatrix(this.diagonalSize);for(const[row,col,value]of this.upperRightEntries())matrix.set(row,col,value);return matrix}toMatrix(){return new Matrix(this)}get(rowIndex,columnIndex){return this.#matrix.get(rowIndex,columnIndex)}set(rowIndex,columnIndex,value){return this.#matrix.set(rowIndex,columnIndex,value),this.#matrix.set(columnIndex,rowIndex,value),this}removeCross(index){return this.#matrix.removeRow(index),this.#matrix.removeColumn(index),this}addCross(index,array){void 0===array&&(array=index,index=this.diagonalSize);const row=array.slice();return row.splice(index,1),this.#matrix.addRow(index,row),this.#matrix.addColumn(index,array),this}applyMask(mask){if(mask.length!==this.diagonalSize)throw new RangeError("Mask size do not match with matrix size");const sidesToRemove=[];for(const[index,passthroughs]of mask.entries())passthroughs||sidesToRemove.push(index);sidesToRemove.reverse();for(const sideIndex of sidesToRemove)this.removeCross(sideIndex);return this}toCompact(){const{diagonalSize}=this,compact=new Array(diagonalSize*(diagonalSize+1)/2);for(let col=0,row=0,index=0;index<compact.length;index++)compact[index]=this.get(row,col),++col>=diagonalSize&&(col=++row);return compact}static fromCompact(compact){const compactSize=compact.length,diagonalSize=(Math.sqrt(8*compactSize+1)-1)/2;if(!Number.isInteger(diagonalSize))throw new TypeError(`This array is not a compact representation of a Symmetric Matrix, ${JSON.stringify(compact)}`);const matrix=new SymmetricMatrix(diagonalSize);for(let col=0,row=0,index=0;index<compactSize;index++)matrix.set(col,row,compact[index]),++col>=diagonalSize&&(col=++row);return matrix}*upperRightEntries(){for(let row=0,col=0;row<this.diagonalSize;void 0){const value=this.get(row,col);yield[row,col,value],++col>=this.diagonalSize&&(col=++row)}}*upperRightValues(){for(let row=0,col=0;row<this.diagonalSize;void 0){const value=this.get(row,col);yield value,++col>=this.diagonalSize&&(col=++row)}}}SymmetricMatrix.prototype.klassType="SymmetricMatrix";class DistanceMatrix extends SymmetricMatrix{static isDistanceMatrix(value){return SymmetricMatrix.isSymmetricMatrix(value)&&"DistanceMatrix"===value.klassSubType}constructor(sideSize){if(super(sideSize),!this.isDistance())throw new TypeError("Provided arguments do no produce a distance matrix")}set(rowIndex,columnIndex,value){return rowIndex===columnIndex&&(value=0),super.set(rowIndex,columnIndex,value)}addCross(index,array){return void 0===array&&(array=index,index=this.diagonalSize),(array=array.slice())[index]=0,super.addCross(index,array)}toSymmetricMatrix(){return new SymmetricMatrix(this)}clone(){const matrix=new DistanceMatrix(this.diagonalSize);for(const[row,col,value]of this.upperRightEntries())row!==col&&matrix.set(row,col,value);return matrix}toCompact(){const{diagonalSize}=this,compact=new Array((diagonalSize-1)*diagonalSize/2);for(let col=1,row=0,index=0;index<compact.length;index++)compact[index]=this.get(row,col),++col>=diagonalSize&&(col=1+ ++row);return compact}static fromCompact(compact){const compactSize=compact.length;if(0===compactSize)return new this(0);const diagonalSize=(Math.sqrt(8*compactSize+1)+1)/2;if(!Number.isInteger(diagonalSize))throw new TypeError(`This array is not a compact representation of a DistanceMatrix, ${JSON.stringify(compact)}`);const matrix=new this(diagonalSize);for(let col=1,row=0,index=0;index<compactSize;index++)matrix.set(col,row,compact[index]),++col>=diagonalSize&&(col=1+ ++row);return matrix}}DistanceMatrix.prototype.klassSubType="DistanceMatrix";class BaseView extends AbstractMatrix{constructor(matrix,rows,columns){super(),this.matrix=matrix,this.rows=rows,this.columns=columns}}class MatrixSelectionView extends BaseView{constructor(matrix,rowIndices,columnIndices){checkRowIndices(matrix,rowIndices),checkColumnIndices(matrix,columnIndices),super(matrix,rowIndices.length,columnIndices.length),this.rowIndices=rowIndices,this.columnIndices=columnIndices}set(rowIndex,columnIndex,value){return this.matrix.set(this.rowIndices[rowIndex],this.columnIndices[columnIndex],value),this}get(rowIndex,columnIndex){return this.matrix.get(this.rowIndices[rowIndex],this.columnIndices[columnIndex])}}class WrapperMatrix1D extends AbstractMatrix{constructor(data,options={}){const{rows=1}=options;if(data.length%rows!=0)throw new Error("the data length is not divisible by the number of rows");super(),this.rows=rows,this.columns=data.length/rows,this.data=data}set(rowIndex,columnIndex,value){let index=this._calculateIndex(rowIndex,columnIndex);return this.data[index]=value,this}get(rowIndex,columnIndex){let index=this._calculateIndex(rowIndex,columnIndex);return this.data[index]}_calculateIndex(row,column){return row*this.columns+column}}class WrapperMatrix2D extends AbstractMatrix{constructor(data){super(),this.data=data,this.rows=data.length,this.columns=data[0].length}set(rowIndex,columnIndex,value){return this.data[rowIndex][columnIndex]=value,this}get(rowIndex,columnIndex){return this.data[rowIndex][columnIndex]}}class LuDecomposition{constructor(matrix){let i,j,k,p,s,t,v,LUcolj,kmax,lu=(matrix=WrapperMatrix2D.checkMatrix(matrix)).clone(),rows=lu.rows,columns=lu.columns,pivotVector=new Float64Array(rows),pivotSign=1;for(i=0;i<rows;i++)pivotVector[i]=i;for(LUcolj=new Float64Array(rows),j=0;j<columns;j++){for(i=0;i<rows;i++)LUcolj[i]=lu.get(i,j);for(i=0;i<rows;i++){for(kmax=Math.min(i,j),s=0,k=0;k<kmax;k++)s+=lu.get(i,k)*LUcolj[k];LUcolj[i]-=s,lu.set(i,j,LUcolj[i])}for(p=j,i=j+1;i<rows;i++)Math.abs(LUcolj[i])>Math.abs(LUcolj[p])&&(p=i);if(p!==j){for(k=0;k<columns;k++)t=lu.get(p,k),lu.set(p,k,lu.get(j,k)),lu.set(j,k,t);v=pivotVector[p],pivotVector[p]=pivotVector[j],pivotVector[j]=v,pivotSign=-pivotSign}if(j<rows&&0!==lu.get(j,j))for(i=j+1;i<rows;i++)lu.set(i,j,lu.get(i,j)/lu.get(j,j))}this.LU=lu,this.pivotVector=pivotVector,this.pivotSign=pivotSign}isSingular(){let data=this.LU,col=data.columns;for(let j=0;j<col;j++)if(0===data.get(j,j))return!0;return!1}solve(value){value=Matrix.checkMatrix(value);let lu=this.LU;if(lu.rows!==value.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");let i,j,k,count=value.columns,X=value.subMatrixRow(this.pivotVector,0,count-1),columns=lu.columns;for(k=0;k<columns;k++)for(i=k+1;i<columns;i++)for(j=0;j<count;j++)X.set(i,j,X.get(i,j)-X.get(k,j)*lu.get(i,k));for(k=columns-1;k>=0;k--){for(j=0;j<count;j++)X.set(k,j,X.get(k,j)/lu.get(k,k));for(i=0;i<k;i++)for(j=0;j<count;j++)X.set(i,j,X.get(i,j)-X.get(k,j)*lu.get(i,k))}return X}get determinant(){let data=this.LU;if(!data.isSquare())throw new Error("Matrix must be square");let determinant=this.pivotSign,col=data.columns;for(let j=0;j<col;j++)determinant*=data.get(j,j);return determinant}get lowerTriangularMatrix(){let data=this.LU,rows=data.rows,columns=data.columns,X=new Matrix(rows,columns);for(let i=0;i<rows;i++)for(let j=0;j<columns;j++)i>j?X.set(i,j,data.get(i,j)):i===j?X.set(i,j,1):X.set(i,j,0);return X}get upperTriangularMatrix(){let data=this.LU,rows=data.rows,columns=data.columns,X=new Matrix(rows,columns);for(let i=0;i<rows;i++)for(let j=0;j<columns;j++)i<=j?X.set(i,j,data.get(i,j)):X.set(i,j,0);return X}get pivotPermutationVector(){return Array.from(this.pivotVector)}}function hypotenuse(a,b){let r=0;return Math.abs(a)>Math.abs(b)?(r=b/a,Math.abs(a)*Math.sqrt(1+r*r)):0!==b?(r=a/b,Math.abs(b)*Math.sqrt(1+r*r)):0}class QrDecomposition{constructor(value){let i,j,k,s,qr=(value=WrapperMatrix2D.checkMatrix(value)).clone(),m=value.rows,n=value.columns,rdiag=new Float64Array(n);for(k=0;k<n;k++){let nrm=0;for(i=k;i<m;i++)nrm=hypotenuse(nrm,qr.get(i,k));if(0!==nrm){for(qr.get(k,k)<0&&(nrm=-nrm),i=k;i<m;i++)qr.set(i,k,qr.get(i,k)/nrm);for(qr.set(k,k,qr.get(k,k)+1),j=k+1;j<n;j++){for(s=0,i=k;i<m;i++)s+=qr.get(i,k)*qr.get(i,j);for(s=-s/qr.get(k,k),i=k;i<m;i++)qr.set(i,j,qr.get(i,j)+s*qr.get(i,k))}}rdiag[k]=-nrm}this.QR=qr,this.Rdiag=rdiag}solve(value){value=Matrix.checkMatrix(value);let qr=this.QR,m=qr.rows;if(value.rows!==m)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");let i,j,k,s,count=value.columns,X=value.clone(),n=qr.columns;for(k=0;k<n;k++)for(j=0;j<count;j++){for(s=0,i=k;i<m;i++)s+=qr.get(i,k)*X.get(i,j);for(s=-s/qr.get(k,k),i=k;i<m;i++)X.set(i,j,X.get(i,j)+s*qr.get(i,k))}for(k=n-1;k>=0;k--){for(j=0;j<count;j++)X.set(k,j,X.get(k,j)/this.Rdiag[k]);for(i=0;i<k;i++)for(j=0;j<count;j++)X.set(i,j,X.get(i,j)-X.get(k,j)*qr.get(i,k))}return X.subMatrix(0,n-1,0,count-1)}isFullRank(){let columns=this.QR.columns;for(let i=0;i<columns;i++)if(0===this.Rdiag[i])return!1;return!0}get upperTriangularMatrix(){let i,j,qr=this.QR,n=qr.columns,X=new Matrix(n,n);for(i=0;i<n;i++)for(j=0;j<n;j++)i<j?X.set(i,j,qr.get(i,j)):i===j?X.set(i,j,this.Rdiag[i]):X.set(i,j,0);return X}get orthogonalMatrix(){let i,j,k,s,qr=this.QR,rows=qr.rows,columns=qr.columns,X=new Matrix(rows,columns);for(k=columns-1;k>=0;k--){for(i=0;i<rows;i++)X.set(i,k,0);for(X.set(k,k,1),j=k;j<columns;j++)if(0!==qr.get(k,k)){for(s=0,i=k;i<rows;i++)s+=qr.get(i,k)*X.get(i,j);for(s=-s/qr.get(k,k),i=k;i<rows;i++)X.set(i,j,X.get(i,j)+s*qr.get(i,k))}}return X}}class SingularValueDecomposition{constructor(value,options={}){if((value=WrapperMatrix2D.checkMatrix(value)).isEmpty())throw new Error("Matrix must be non-empty");let m=value.rows,n=value.columns;const{computeLeftSingularVectors=!0,computeRightSingularVectors=!0,autoTranspose=!1}=options;let a,wantu=Boolean(computeLeftSingularVectors),wantv=Boolean(computeRightSingularVectors),swapped=!1;if(m<n)if(autoTranspose){a=value.transpose(),m=a.rows,n=a.columns,swapped=!0;let aux=wantu;wantu=wantv,wantv=aux}else a=value.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else a=value.clone();let nu=Math.min(m,n),ni=Math.min(m+1,n),s=new Float64Array(ni),U=new Matrix(m,nu),V=new Matrix(n,n),e=new Float64Array(n),work=new Float64Array(m),si=new Float64Array(ni);for(let i=0;i<ni;i++)si[i]=i;let nct=Math.min(m-1,n),nrt=Math.max(0,Math.min(n-2,m)),mrc=Math.max(nct,nrt);for(let k=0;k<mrc;k++){if(k<nct){s[k]=0;for(let i=k;i<m;i++)s[k]=hypotenuse(s[k],a.get(i,k));if(0!==s[k]){a.get(k,k)<0&&(s[k]=-s[k]);for(let i=k;i<m;i++)a.set(i,k,a.get(i,k)/s[k]);a.set(k,k,a.get(k,k)+1)}s[k]=-s[k]}for(let j=k+1;j<n;j++){if(k<nct&&0!==s[k]){let t=0;for(let i=k;i<m;i++)t+=a.get(i,k)*a.get(i,j);t=-t/a.get(k,k);for(let i=k;i<m;i++)a.set(i,j,a.get(i,j)+t*a.get(i,k))}e[j]=a.get(k,j)}if(wantu&&k<nct)for(let i=k;i<m;i++)U.set(i,k,a.get(i,k));if(k<nrt){e[k]=0;for(let i=k+1;i<n;i++)e[k]=hypotenuse(e[k],e[i]);if(0!==e[k]){e[k+1]<0&&(e[k]=0-e[k]);for(let i=k+1;i<n;i++)e[i]/=e[k];e[k+1]+=1}if(e[k]=-e[k],k+1<m&&0!==e[k]){for(let i=k+1;i<m;i++)work[i]=0;for(let i=k+1;i<m;i++)for(let j=k+1;j<n;j++)work[i]+=e[j]*a.get(i,j);for(let j=k+1;j<n;j++){let t=-e[j]/e[k+1];for(let i=k+1;i<m;i++)a.set(i,j,a.get(i,j)+t*work[i])}}if(wantv)for(let i=k+1;i<n;i++)V.set(i,k,e[i])}}let p=Math.min(n,m+1);if(nct<n&&(s[nct]=a.get(nct,nct)),m<p&&(s[p-1]=0),nrt+1<p&&(e[nrt]=a.get(nrt,p-1)),e[p-1]=0,wantu){for(let j=nct;j<nu;j++){for(let i=0;i<m;i++)U.set(i,j,0);U.set(j,j,1)}for(let k=nct-1;k>=0;k--)if(0!==s[k]){for(let j=k+1;j<nu;j++){let t=0;for(let i=k;i<m;i++)t+=U.get(i,k)*U.get(i,j);t=-t/U.get(k,k);for(let i=k;i<m;i++)U.set(i,j,U.get(i,j)+t*U.get(i,k))}for(let i=k;i<m;i++)U.set(i,k,-U.get(i,k));U.set(k,k,1+U.get(k,k));for(let i=0;i<k-1;i++)U.set(i,k,0)}else{for(let i=0;i<m;i++)U.set(i,k,0);U.set(k,k,1)}}if(wantv)for(let k=n-1;k>=0;k--){if(k<nrt&&0!==e[k])for(let j=k+1;j<n;j++){let t=0;for(let i=k+1;i<n;i++)t+=V.get(i,k)*V.get(i,j);t=-t/V.get(k+1,k);for(let i=k+1;i<n;i++)V.set(i,j,V.get(i,j)+t*V.get(i,k))}for(let i=0;i<n;i++)V.set(i,k,0);V.set(k,k,1)}let pp=p-1,eps=Number.EPSILON;for(;p>0;){let k,kase;for(k=p-2;k>=-1&&-1!==k;k--){const alpha=Number.MIN_VALUE+eps*Math.abs(s[k]+Math.abs(s[k+1]));if(Math.abs(e[k])<=alpha||Number.isNaN(e[k])){e[k]=0;break}}if(k===p-2)kase=4;else{let ks;for(ks=p-1;ks>=k&&ks!==k;ks--){let t=(ks!==p?Math.abs(e[ks]):0)+(ks!==k+1?Math.abs(e[ks-1]):0);if(Math.abs(s[ks])<=eps*t){s[ks]=0;break}}ks===k?kase=3:ks===p-1?kase=1:(kase=2,k=ks)}switch(k++,kase){case 1:{let f=e[p-2];e[p-2]=0;for(let j=p-2;j>=k;j--){let t=hypotenuse(s[j],f),cs=s[j]/t,sn=f/t;if(s[j]=t,j!==k&&(f=-sn*e[j-1],e[j-1]=cs*e[j-1]),wantv)for(let i=0;i<n;i++)t=cs*V.get(i,j)+sn*V.get(i,p-1),V.set(i,p-1,-sn*V.get(i,j)+cs*V.get(i,p-1)),V.set(i,j,t)}break}case 2:{let f=e[k-1];e[k-1]=0;for(let j=k;j<p;j++){let t=hypotenuse(s[j],f),cs=s[j]/t,sn=f/t;if(s[j]=t,f=-sn*e[j],e[j]=cs*e[j],wantu)for(let i=0;i<m;i++)t=cs*U.get(i,j)+sn*U.get(i,k-1),U.set(i,k-1,-sn*U.get(i,j)+cs*U.get(i,k-1)),U.set(i,j,t)}break}case 3:{const scale=Math.max(Math.abs(s[p-1]),Math.abs(s[p-2]),Math.abs(e[p-2]),Math.abs(s[k]),Math.abs(e[k])),sp=s[p-1]/scale,spm1=s[p-2]/scale,epm1=e[p-2]/scale,sk=s[k]/scale,ek=e[k]/scale,b=((spm1+sp)*(spm1-sp)+epm1*epm1)/2,c=sp*epm1*(sp*epm1);let shift=0;0===b&&0===c||(shift=b<0?0-Math.sqrt(b*b+c):Math.sqrt(b*b+c),shift=c/(b+shift));let f=(sk+sp)*(sk-sp)+shift,g=sk*ek;for(let j=k;j<p-1;j++){let t=hypotenuse(f,g);0===t&&(t=Number.MIN_VALUE);let cs=f/t,sn=g/t;if(j!==k&&(e[j-1]=t),f=cs*s[j]+sn*e[j],e[j]=cs*e[j]-sn*s[j],g=sn*s[j+1],s[j+1]=cs*s[j+1],wantv)for(let i=0;i<n;i++)t=cs*V.get(i,j)+sn*V.get(i,j+1),V.set(i,j+1,-sn*V.get(i,j)+cs*V.get(i,j+1)),V.set(i,j,t);if(t=hypotenuse(f,g),0===t&&(t=Number.MIN_VALUE),cs=f/t,sn=g/t,s[j]=t,f=cs*e[j]+sn*s[j+1],s[j+1]=-sn*e[j]+cs*s[j+1],g=sn*e[j+1],e[j+1]=cs*e[j+1],wantu&&j<m-1)for(let i=0;i<m;i++)t=cs*U.get(i,j)+sn*U.get(i,j+1),U.set(i,j+1,-sn*U.get(i,j)+cs*U.get(i,j+1)),U.set(i,j,t)}e[p-2]=f;break}case 4:if(s[k]<=0&&(s[k]=s[k]<0?-s[k]:0,wantv))for(let i=0;i<=pp;i++)V.set(i,k,-V.get(i,k));for(;k<pp&&!(s[k]>=s[k+1]);){let t=s[k];if(s[k]=s[k+1],s[k+1]=t,wantv&&k<n-1)for(let i=0;i<n;i++)t=V.get(i,k+1),V.set(i,k+1,V.get(i,k)),V.set(i,k,t);if(wantu&&k<m-1)for(let i=0;i<m;i++)t=U.get(i,k+1),U.set(i,k+1,U.get(i,k)),U.set(i,k,t);k++}p--}}if(swapped){let tmp=V;V=U,U=tmp}this.m=m,this.n=n,this.s=s,this.U=U,this.V=V}solve(value){let Y=value,e=this.threshold,scols=this.s.length,Ls=Matrix.zeros(scols,scols);for(let i=0;i<scols;i++)Math.abs(this.s[i])<=e?Ls.set(i,i,0):Ls.set(i,i,1/this.s[i]);let U=this.U,V=this.rightSingularVectors,VL=V.mmul(Ls),vrows=V.rows,urows=U.rows,VLU=Matrix.zeros(vrows,urows);for(let i=0;i<vrows;i++)for(let j=0;j<urows;j++){let sum=0;for(let k=0;k<scols;k++)sum+=VL.get(i,k)*U.get(j,k);VLU.set(i,j,sum)}return VLU.mmul(Y)}solveForDiagonal(value){return this.solve(Matrix.diag(value))}inverse(){let V=this.V,e=this.threshold,vrows=V.rows,vcols=V.columns,X=new Matrix(vrows,this.s.length);for(let i=0;i<vrows;i++)for(let j=0;j<vcols;j++)Math.abs(this.s[j])>e&&X.set(i,j,V.get(i,j)/this.s[j]);let U=this.U,urows=U.rows,ucols=U.columns,Y=new Matrix(vrows,urows);for(let i=0;i<vrows;i++)for(let j=0;j<urows;j++){let sum=0;for(let k=0;k<ucols;k++)sum+=X.get(i,k)*U.get(j,k);Y.set(i,j,sum)}return Y}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let tol=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,r=0,s=this.s;for(let i=0,ii=s.length;i<ii;i++)s[i]>tol&&r++;return r}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return Matrix.diag(this.s)}}function solve(leftHandSide,rightHandSide,useSVD=!1){return leftHandSide=WrapperMatrix2D.checkMatrix(leftHandSide),rightHandSide=WrapperMatrix2D.checkMatrix(rightHandSide),useSVD?new SingularValueDecomposition(leftHandSide).solve(rightHandSide):leftHandSide.isSquare()?new LuDecomposition(leftHandSide).solve(rightHandSide):new QrDecomposition(leftHandSide).solve(rightHandSide)}function xrange(n,exception){let range=[];for(let i=0;i<n;i++)i!==exception&&range.push(i);return range}function dependenciesOneRow(error,matrix,index,thresholdValue=1e-9,thresholdError=1e-9){if(error>thresholdError)return new Array(matrix.rows+1).fill(0);{let returnArray=matrix.addRow(index,[0]);for(let i=0;i<returnArray.rows;i++)Math.abs(returnArray.get(i,0))<thresholdValue&&returnArray.set(i,0,0);return returnArray.to1DArray()}}class EigenvalueDecomposition{constructor(matrix,options={}){const{assumeSymmetric=!1}=options;if(!(matrix=WrapperMatrix2D.checkMatrix(matrix)).isSquare())throw new Error("Matrix is not a square matrix");if(matrix.isEmpty())throw new Error("Matrix must be non-empty");let i,j,n=matrix.columns,V=new Matrix(n,n),d=new Float64Array(n),e=new Float64Array(n),value=matrix,isSymmetric=!1;if(isSymmetric=!!assumeSymmetric||matrix.isSymmetric(),isSymmetric){for(i=0;i<n;i++)for(j=0;j<n;j++)V.set(i,j,value.get(i,j));!function tred2(n,e,d,V){let f,g,h,i,j,k,hh,scale;for(j=0;j<n;j++)d[j]=V.get(n-1,j);for(i=n-1;i>0;i--){for(scale=0,h=0,k=0;k<i;k++)scale+=Math.abs(d[k]);if(0===scale)for(e[i]=d[i-1],j=0;j<i;j++)d[j]=V.get(i-1,j),V.set(i,j,0),V.set(j,i,0);else{for(k=0;k<i;k++)d[k]/=scale,h+=d[k]*d[k];for(f=d[i-1],g=Math.sqrt(h),f>0&&(g=-g),e[i]=scale*g,h-=f*g,d[i-1]=f-g,j=0;j<i;j++)e[j]=0;for(j=0;j<i;j++){for(f=d[j],V.set(j,i,f),g=e[j]+V.get(j,j)*f,k=j+1;k<=i-1;k++)g+=V.get(k,j)*d[k],e[k]+=V.get(k,j)*f;e[j]=g}for(f=0,j=0;j<i;j++)e[j]/=h,f+=e[j]*d[j];for(hh=f/(h+h),j=0;j<i;j++)e[j]-=hh*d[j];for(j=0;j<i;j++){for(f=d[j],g=e[j],k=j;k<=i-1;k++)V.set(k,j,V.get(k,j)-(f*e[k]+g*d[k]));d[j]=V.get(i-1,j),V.set(i,j,0)}}d[i]=h}for(i=0;i<n-1;i++){if(V.set(n-1,i,V.get(i,i)),V.set(i,i,1),h=d[i+1],0!==h){for(k=0;k<=i;k++)d[k]=V.get(k,i+1)/h;for(j=0;j<=i;j++){for(g=0,k=0;k<=i;k++)g+=V.get(k,i+1)*V.get(k,j);for(k=0;k<=i;k++)V.set(k,j,V.get(k,j)-g*d[k])}}for(k=0;k<=i;k++)V.set(k,i+1,0)}for(j=0;j<n;j++)d[j]=V.get(n-1,j),V.set(n-1,j,0);V.set(n-1,n-1,1),e[0]=0}(n,e,d,V),function tql2(n,e,d,V){let g,h,i,j,k,l,m,p,r,dl1,c,c2,c3,el1,s,s2;for(i=1;i<n;i++)e[i-1]=e[i];e[n-1]=0;let f=0,tst1=0,eps=Number.EPSILON;for(l=0;l<n;l++){for(tst1=Math.max(tst1,Math.abs(d[l])+Math.abs(e[l])),m=l;m<n&&!(Math.abs(e[m])<=eps*tst1);)m++;if(m>l)do{for(g=d[l],p=(d[l+1]-g)/(2*e[l]),r=hypotenuse(p,1),p<0&&(r=-r),d[l]=e[l]/(p+r),d[l+1]=e[l]*(p+r),dl1=d[l+1],h=g-d[l],i=l+2;i<n;i++)d[i]-=h;for(f+=h,p=d[m],c=1,c2=c,c3=c,el1=e[l+1],s=0,s2=0,i=m-1;i>=l;i--)for(c3=c2,c2=c,s2=s,g=c*e[i],h=c*p,r=hypotenuse(p,e[i]),e[i+1]=s*r,s=e[i]/r,c=p/r,p=c*d[i]-s*g,d[i+1]=h+s*(c*g+s*d[i]),k=0;k<n;k++)h=V.get(k,i+1),V.set(k,i+1,s*V.get(k,i)+c*h),V.set(k,i,c*V.get(k,i)-s*h);p=-s*s2*c3*el1*e[l]/dl1,e[l]=s*p,d[l]=c*p}while(Math.abs(e[l])>eps*tst1);d[l]=d[l]+f,e[l]=0}for(i=0;i<n-1;i++){for(k=i,p=d[i],j=i+1;j<n;j++)d[j]<p&&(k=j,p=d[j]);if(k!==i)for(d[k]=d[i],d[i]=p,j=0;j<n;j++)p=V.get(j,i),V.set(j,i,V.get(j,k)),V.set(j,k,p)}}(n,e,d,V)}else{let H=new Matrix(n,n),ort=new Float64Array(n);for(j=0;j<n;j++)for(i=0;i<n;i++)H.set(i,j,value.get(i,j));!function orthes(n,H,ort,V){let f,g,h,i,j,m,scale,low=0,high=n-1;for(m=low+1;m<=high-1;m++){for(scale=0,i=m;i<=high;i++)scale+=Math.abs(H.get(i,m-1));if(0!==scale){for(h=0,i=high;i>=m;i--)ort[i]=H.get(i,m-1)/scale,h+=ort[i]*ort[i];for(g=Math.sqrt(h),ort[m]>0&&(g=-g),h-=ort[m]*g,ort[m]=ort[m]-g,j=m;j<n;j++){for(f=0,i=high;i>=m;i--)f+=ort[i]*H.get(i,j);for(f/=h,i=m;i<=high;i++)H.set(i,j,H.get(i,j)-f*ort[i])}for(i=0;i<=high;i++){for(f=0,j=high;j>=m;j--)f+=ort[j]*H.get(i,j);for(f/=h,j=m;j<=high;j++)H.set(i,j,H.get(i,j)-f*ort[j])}ort[m]=scale*ort[m],H.set(m,m-1,scale*g)}}for(i=0;i<n;i++)for(j=0;j<n;j++)V.set(i,j,i===j?1:0);for(m=high-1;m>=low+1;m--)if(0!==H.get(m,m-1)){for(i=m+1;i<=high;i++)ort[i]=H.get(i,m-1);for(j=m;j<=high;j++){for(g=0,i=m;i<=high;i++)g+=ort[i]*V.get(i,j);for(g=g/ort[m]/H.get(m,m-1),i=m;i<=high;i++)V.set(i,j,V.get(i,j)+g*ort[i])}}}(n,H,ort,V),function hqr2(nn,e,d,V,H){let i,j,k,l,m,t,w,x,y,ra,sa,vr,vi,notlast,cdivres,n=nn-1,low=0,high=nn-1,eps=Number.EPSILON,exshift=0,norm=0,p=0,q=0,r=0,s=0,z=0,iter=0;for(i=0;i<nn;i++)for((i<low||i>high)&&(d[i]=H.get(i,i),e[i]=0),j=Math.max(i-1,0);j<nn;j++)norm+=Math.abs(H.get(i,j));for(;n>=low;){for(l=n;l>low&&(s=Math.abs(H.get(l-1,l-1))+Math.abs(H.get(l,l)),0===s&&(s=norm),!(Math.abs(H.get(l,l-1))<eps*s));)l--;if(l===n)H.set(n,n,H.get(n,n)+exshift),d[n]=H.get(n,n),e[n]=0,n--,iter=0;else if(l===n-1){if(w=H.get(n,n-1)*H.get(n-1,n),p=(H.get(n-1,n-1)-H.get(n,n))/2,q=p*p+w,z=Math.sqrt(Math.abs(q)),H.set(n,n,H.get(n,n)+exshift),H.set(n-1,n-1,H.get(n-1,n-1)+exshift),x=H.get(n,n),q>=0){for(z=p>=0?p+z:p-z,d[n-1]=x+z,d[n]=d[n-1],0!==z&&(d[n]=x-w/z),e[n-1]=0,e[n]=0,x=H.get(n,n-1),s=Math.abs(x)+Math.abs(z),p=x/s,q=z/s,r=Math.sqrt(p*p+q*q),p/=r,q/=r,j=n-1;j<nn;j++)z=H.get(n-1,j),H.set(n-1,j,q*z+p*H.get(n,j)),H.set(n,j,q*H.get(n,j)-p*z);for(i=0;i<=n;i++)z=H.get(i,n-1),H.set(i,n-1,q*z+p*H.get(i,n)),H.set(i,n,q*H.get(i,n)-p*z);for(i=low;i<=high;i++)z=V.get(i,n-1),V.set(i,n-1,q*z+p*V.get(i,n)),V.set(i,n,q*V.get(i,n)-p*z)}else d[n-1]=x+p,d[n]=x+p,e[n-1]=z,e[n]=-z;n-=2,iter=0}else{if(x=H.get(n,n),y=0,w=0,l<n&&(y=H.get(n-1,n-1),w=H.get(n,n-1)*H.get(n-1,n)),10===iter){for(exshift+=x,i=low;i<=n;i++)H.set(i,i,H.get(i,i)-x);s=Math.abs(H.get(n,n-1))+Math.abs(H.get(n-1,n-2)),x=y=.75*s,w=-.4375*s*s}if(30===iter&&(s=(y-x)/2,s=s*s+w,s>0)){for(s=Math.sqrt(s),y<x&&(s=-s),s=x-w/((y-x)/2+s),i=low;i<=n;i++)H.set(i,i,H.get(i,i)-s);exshift+=s,x=y=w=.964}for(iter+=1,m=n-2;m>=l&&(z=H.get(m,m),r=x-z,s=y-z,p=(r*s-w)/H.get(m+1,m)+H.get(m,m+1),q=H.get(m+1,m+1)-z-r-s,r=H.get(m+2,m+1),s=Math.abs(p)+Math.abs(q)+Math.abs(r),p/=s,q/=s,r/=s,m!==l)&&!(Math.abs(H.get(m,m-1))*(Math.abs(q)+Math.abs(r))<eps*(Math.abs(p)*(Math.abs(H.get(m-1,m-1))+Math.abs(z)+Math.abs(H.get(m+1,m+1)))));)m--;for(i=m+2;i<=n;i++)H.set(i,i-2,0),i>m+2&&H.set(i,i-3,0);for(k=m;k<=n-1&&(notlast=k!==n-1,k!==m&&(p=H.get(k,k-1),q=H.get(k+1,k-1),r=notlast?H.get(k+2,k-1):0,x=Math.abs(p)+Math.abs(q)+Math.abs(r),0!==x&&(p/=x,q/=x,r/=x)),0!==x);k++)if(s=Math.sqrt(p*p+q*q+r*r),p<0&&(s=-s),0!==s){for(k!==m?H.set(k,k-1,-s*x):l!==m&&H.set(k,k-1,-H.get(k,k-1)),p+=s,x=p/s,y=q/s,z=r/s,q/=p,r/=p,j=k;j<nn;j++)p=H.get(k,j)+q*H.get(k+1,j),notlast&&(p+=r*H.get(k+2,j),H.set(k+2,j,H.get(k+2,j)-p*z)),H.set(k,j,H.get(k,j)-p*x),H.set(k+1,j,H.get(k+1,j)-p*y);for(i=0;i<=Math.min(n,k+3);i++)p=x*H.get(i,k)+y*H.get(i,k+1),notlast&&(p+=z*H.get(i,k+2),H.set(i,k+2,H.get(i,k+2)-p*r)),H.set(i,k,H.get(i,k)-p),H.set(i,k+1,H.get(i,k+1)-p*q);for(i=low;i<=high;i++)p=x*V.get(i,k)+y*V.get(i,k+1),notlast&&(p+=z*V.get(i,k+2),V.set(i,k+2,V.get(i,k+2)-p*r)),V.set(i,k,V.get(i,k)-p),V.set(i,k+1,V.get(i,k+1)-p*q)}}}if(0===norm)return;for(n=nn-1;n>=0;n--)if(p=d[n],q=e[n],0===q)for(l=n,H.set(n,n,1),i=n-1;i>=0;i--){for(w=H.get(i,i)-p,r=0,j=l;j<=n;j++)r+=H.get(i,j)*H.get(j,n);if(e[i]<0)z=w,s=r;else if(l=i,0===e[i]?H.set(i,n,0!==w?-r/w:-r/(eps*norm)):(x=H.get(i,i+1),y=H.get(i+1,i),q=(d[i]-p)*(d[i]-p)+e[i]*e[i],t=(x*s-z*r)/q,H.set(i,n,t),H.set(i+1,n,Math.abs(x)>Math.abs(z)?(-r-w*t)/x:(-s-y*t)/z)),t=Math.abs(H.get(i,n)),eps*t*t>1)for(j=i;j<=n;j++)H.set(j,n,H.get(j,n)/t)}else if(q<0)for(l=n-1,Math.abs(H.get(n,n-1))>Math.abs(H.get(n-1,n))?(H.set(n-1,n-1,q/H.get(n,n-1)),H.set(n-1,n,-(H.get(n,n)-p)/H.get(n,n-1))):(cdivres=cdiv(0,-H.get(n-1,n),H.get(n-1,n-1)-p,q),H.set(n-1,n-1,cdivres[0]),H.set(n-1,n,cdivres[1])),H.set(n,n-1,0),H.set(n,n,1),i=n-2;i>=0;i--){for(ra=0,sa=0,j=l;j<=n;j++)ra+=H.get(i,j)*H.get(j,n-1),sa+=H.get(i,j)*H.get(j,n);if(w=H.get(i,i)-p,e[i]<0)z=w,r=ra,s=sa;else if(l=i,0===e[i]?(cdivres=cdiv(-ra,-sa,w,q),H.set(i,n-1,cdivres[0]),H.set(i,n,cdivres[1])):(x=H.get(i,i+1),y=H.get(i+1,i),vr=(d[i]-p)*(d[i]-p)+e[i]*e[i]-q*q,vi=2*(d[i]-p)*q,0===vr&&0===vi&&(vr=eps*norm*(Math.abs(w)+Math.abs(q)+Math.abs(x)+Math.abs(y)+Math.abs(z))),cdivres=cdiv(x*r-z*ra+q*sa,x*s-z*sa-q*ra,vr,vi),H.set(i,n-1,cdivres[0]),H.set(i,n,cdivres[1]),Math.abs(x)>Math.abs(z)+Math.abs(q)?(H.set(i+1,n-1,(-ra-w*H.get(i,n-1)+q*H.get(i,n))/x),H.set(i+1,n,(-sa-w*H.get(i,n)-q*H.get(i,n-1))/x)):(cdivres=cdiv(-r-y*H.get(i,n-1),-s-y*H.get(i,n),z,q),H.set(i+1,n-1,cdivres[0]),H.set(i+1,n,cdivres[1]))),t=Math.max(Math.abs(H.get(i,n-1)),Math.abs(H.get(i,n))),eps*t*t>1)for(j=i;j<=n;j++)H.set(j,n-1,H.get(j,n-1)/t),H.set(j,n,H.get(j,n)/t)}for(i=0;i<nn;i++)if(i<low||i>high)for(j=i;j<nn;j++)V.set(i,j,H.get(i,j));for(j=nn-1;j>=low;j--)for(i=low;i<=high;i++){for(z=0,k=low;k<=Math.min(j,high);k++)z+=V.get(i,k)*H.get(k,j);V.set(i,j,z)}}(n,e,d,V,H)}this.n=n,this.e=e,this.d=d,this.V=V}get realEigenvalues(){return Array.from(this.d)}get imaginaryEigenvalues(){return Array.from(this.e)}get eigenvectorMatrix(){return this.V}get diagonalMatrix(){let i,j,n=this.n,e=this.e,d=this.d,X=new Matrix(n,n);for(i=0;i<n;i++){for(j=0;j<n;j++)X.set(i,j,0);X.set(i,i,d[i]),e[i]>0?X.set(i,i+1,e[i]):e[i]<0&&X.set(i,i-1,e[i])}return X}}function cdiv(xr,xi,yr,yi){let r,d;return Math.abs(yr)>Math.abs(yi)?(r=yi/yr,d=yr+r*yi,[(xr+r*xi)/d,(xi-r*xr)/d]):(r=yr/yi,d=yi+r*yr,[(r*xr+xi)/d,(r*xi-xr)/d])}class CholeskyDecomposition{constructor(value){if(!(value=WrapperMatrix2D.checkMatrix(value)).isSymmetric())throw new Error("Matrix is not symmetric");let i,j,k,a=value,dimension=a.rows,l=new Matrix(dimension,dimension),positiveDefinite=!0;for(j=0;j<dimension;j++){let d=0;for(k=0;k<j;k++){let s=0;for(i=0;i<k;i++)s+=l.get(k,i)*l.get(j,i);s=(a.get(j,k)-s)/l.get(k,k),l.set(j,k,s),d+=s*s}for(d=a.get(j,j)-d,positiveDefinite&&=d>0,l.set(j,j,Math.sqrt(Math.max(d,0))),k=j+1;k<dimension;k++)l.set(j,k,0)}this.L=l,this.positiveDefinite=positiveDefinite}isPositiveDefinite(){return this.positiveDefinite}solve(value){value=WrapperMatrix2D.checkMatrix(value);let l=this.L,dimension=l.rows;if(value.rows!==dimension)throw new Error("Matrix dimensions do not match");if(!1===this.isPositiveDefinite())throw new Error("Matrix is not positive definite");let i,j,k,count=value.columns,B=value.clone();for(k=0;k<dimension;k++)for(j=0;j<count;j++){for(i=0;i<k;i++)B.set(k,j,B.get(k,j)-B.get(i,j)*l.get(k,i));B.set(k,j,B.get(k,j)/l.get(k,k))}for(k=dimension-1;k>=0;k--)for(j=0;j<count;j++){for(i=k+1;i<dimension;i++)B.set(k,j,B.get(k,j)-B.get(i,j)*l.get(i,k));B.set(k,j,B.get(k,j)/l.get(k,k))}return B}get lowerTriangularMatrix(){return this.L}}class nipals{constructor(X,options={}){X=WrapperMatrix2D.checkMatrix(X);let{Y}=options;const{scaleScores=!1,maxIterations=1e3,terminationCriteria=1e-10}=options;let u;if(Y){if(Y=isAnyArray.isAnyArray(Y)&&"number"==typeof Y[0]?Matrix.columnVector(Y):WrapperMatrix2D.checkMatrix(Y),Y.rows!==X.rows)throw new Error("Y should have the same number of rows as X");u=Y.getColumnVector(0)}else u=X.getColumnVector(0);let t,q,w,tOld,diff=1;for(let counter=0;counter<maxIterations&&diff>terminationCriteria;counter++)w=X.transpose().mmul(u).div(u.transpose().mmul(u).get(0,0)),w=w.div(w.norm()),t=X.mmul(w).div(w.transpose().mmul(w).get(0,0)),counter>0&&(diff=t.clone().sub(tOld).pow(2).sum()),tOld=t.clone(),Y?(q=Y.transpose().mmul(t).div(t.transpose().mmul(t).get(0,0)),q=q.div(q.norm()),u=Y.mmul(q).div(q.transpose().mmul(q).get(0,0))):u=t;if(Y){let p=X.transpose().mmul(t).div(t.transpose().mmul(t).get(0,0));p=p.div(p.norm());let xResidual=X.clone().sub(t.clone().mmul(p.transpose())),residual=u.transpose().mmul(t).div(t.transpose().mmul(t).get(0,0)),yResidual=Y.clone().sub(t.clone().mulS(residual.get(0,0)).mmul(q.transpose()));this.t=t,this.p=p.transpose(),this.w=w.transpose(),this.q=q,this.u=u,this.s=t.transpose().mmul(t),this.xResidual=xResidual,this.yResidual=yResidual,this.betas=residual}else this.w=w.transpose(),this.s=t.transpose().mmul(t).sqrt(),this.t=scaleScores?t.clone().div(this.s.get(0,0)):t,this.xResidual=X.sub(t.mmul(w.transpose()))}}exports.y3=AbstractMatrix,exports.jy=CholeskyDecomposition,exports.oN=CholeskyDecomposition,exports.Hc=DistanceMatrix,exports.cg=EigenvalueDecomposition,exports.hj=EigenvalueDecomposition,exports.LU=LuDecomposition,exports.Tb=LuDecomposition,exports.uq=Matrix,exports.Zm=class MatrixColumnSelectionView extends BaseView{constructor(matrix,columnIndices){checkColumnIndices(matrix,columnIndices),super(matrix,matrix.rows,columnIndices.length),this.columnIndices=columnIndices}set(rowIndex,columnIndex,value){return this.matrix.set(rowIndex,this.columnIndices[columnIndex],value),this}get(rowIndex,columnIndex){return this.matrix.get(rowIndex,this.columnIndices[columnIndex])}},exports.Dq=class MatrixColumnView extends BaseView{constructor(matrix,column){checkColumnIndex(matrix,column),super(matrix,matrix.rows,1),this.column=column}set(rowIndex,columnIndex,value){return this.matrix.set(rowIndex,this.column,value),this}get(rowIndex){return this.matrix.get(rowIndex,this.column)}},exports.__=class MatrixFlipColumnView extends BaseView{constructor(matrix){super(matrix,matrix.rows,matrix.columns)}set(rowIndex,columnIndex,value){return this.matrix.set(rowIndex,this.columns-columnIndex-1,value),this}get(rowIndex,columnIndex){return this.matrix.get(rowIndex,this.columns-columnIndex-1)}},exports.q0=class MatrixFlipRowView extends BaseView{constructor(matrix){super(matrix,matrix.rows,matrix.columns)}set(rowIndex,columnIndex,value){return this.matrix.set(this.rows-rowIndex-1,columnIndex,value),this}get(rowIndex,columnIndex){return this.matrix.get(this.rows-rowIndex-1,columnIndex)}},exports.lh=class MatrixRowSelectionView extends BaseView{constructor(matrix,rowIndices){checkRowIndices(matrix,rowIndices),super(matrix,rowIndices.length,matrix.columns),this.rowIndices=rowIndices}set(rowIndex,columnIndex,value){return this.matrix.set(this.rowIndices[rowIndex],columnIndex,value),this}get(rowIndex,columnIndex){return this.matrix.get(this.rowIndices[rowIndex],columnIndex)}},exports.pI=class MatrixRowView extends BaseView{constructor(matrix,row){checkRowIndex(matrix,row),super(matrix,1,matrix.columns),this.row=row}set(rowIndex,columnIndex,value){return this.matrix.set(this.row,columnIndex,value),this}get(rowIndex,columnIndex){return this.matrix.get(this.row,columnIndex)}},exports.zC=MatrixSelectionView,exports.zg=class MatrixSubView extends BaseView{constructor(matrix,startRow,endRow,startColumn,endColumn){checkRange(matrix,startRow,endRow,startColumn,endColumn),super(matrix,endRow-startRow+1,endColumn-startColumn+1),this.startRow=startRow,this.startColumn=startColumn}set(rowIndex,columnIndex,value){return this.matrix.set(this.startRow+rowIndex,this.startColumn+columnIndex,value),this}get(rowIndex,columnIndex){return this.matrix.get(this.startRow+rowIndex,this.startColumn+columnIndex)}},exports.g6=class MatrixTransposeView extends BaseView{constructor(matrix){super(matrix,matrix.columns,matrix.rows)}set(rowIndex,columnIndex,value){return this.matrix.set(columnIndex,rowIndex,value),this}get(rowIndex,columnIndex){return this.matrix.get(columnIndex,rowIndex)}},exports.OL=nipals,exports.ks=nipals,exports.QR=QrDecomposition,exports.jp=QrDecomposition,exports.mk=SingularValueDecomposition,exports.W2=SingularValueDecomposition,exports.l=SymmetricMatrix,exports.KY=WrapperMatrix1D,exports.dv=WrapperMatrix2D,exports.BR=function correlation(xMatrix,yMatrix=xMatrix,options={}){xMatrix=new Matrix(xMatrix);let yIsSame=!1;if("object"!=typeof yMatrix||Matrix.isMatrix(yMatrix)||isAnyArray.isAnyArray(yMatrix)?yMatrix=new Matrix(yMatrix):(options=yMatrix,yMatrix=xMatrix,yIsSame=!0),xMatrix.rows!==yMatrix.rows)throw new TypeError("Both matrices must have the same number of rows");const{center=!0,scale=!0}=options;center&&(xMatrix.center("column"),yIsSame||yMatrix.center("column")),scale&&(xMatrix.scale("column"),yIsSame||yMatrix.scale("column"));const sdx=xMatrix.standardDeviation("column",{unbiased:!0}),sdy=yIsSame?sdx:yMatrix.standardDeviation("column",{unbiased:!0}),corr=xMatrix.transpose().mmul(yMatrix);for(let i=0;i<corr.rows;i++)for(let j=0;j<corr.columns;j++)corr.set(i,j,corr.get(i,j)*(1/(sdx[i]*sdy[j]))*(1/(xMatrix.rows-1)));return corr},exports.Wu=function covariance(xMatrix,yMatrix=xMatrix,options={}){xMatrix=new Matrix(xMatrix);let yIsSame=!1;if("object"!=typeof yMatrix||Matrix.isMatrix(yMatrix)||isAnyArray.isAnyArray(yMatrix)?yMatrix=new Matrix(yMatrix):(options=yMatrix,yMatrix=xMatrix,yIsSame=!0),xMatrix.rows!==yMatrix.rows)throw new TypeError("Both matrices must have the same number of rows");const{center=!0}=options;center&&(xMatrix=xMatrix.center("column"),yIsSame||(yMatrix=yMatrix.center("column")));const cov=xMatrix.transpose().mmul(yMatrix);for(let i=0;i<cov.rows;i++)for(let j=0;j<cov.columns;j++)cov.set(i,j,cov.get(i,j)*(1/(xMatrix.rows-1)));return cov},exports.Ay=Matrix,exports.a4=function determinant(matrix){if((matrix=Matrix.checkMatrix(matrix)).isSquare()){if(0===matrix.columns)return 1;let a,b,c,d;if(2===matrix.columns)return a=matrix.get(0,0),b=matrix.get(0,1),c=matrix.get(1,0),d=matrix.get(1,1),a*d-b*c;if(3===matrix.columns){let subMatrix0,subMatrix1,subMatrix2;return subMatrix0=new MatrixSelectionView(matrix,[1,2],[1,2]),subMatrix1=new MatrixSelectionView(matrix,[1,2],[0,2]),subMatrix2=new MatrixSelectionView(matrix,[1,2],[0,1]),a=matrix.get(0,0),b=matrix.get(0,1),c=matrix.get(0,2),a*determinant(subMatrix0)-b*determinant(subMatrix1)+c*determinant(subMatrix2)}return new LuDecomposition(matrix).determinant}throw Error("determinant can only be calculated for a square matrix")},exports.DI=function inverse(matrix,useSVD=!1){return matrix=WrapperMatrix2D.checkMatrix(matrix),useSVD?new SingularValueDecomposition(matrix).inverse():solve(matrix,Matrix.eye(matrix.rows))},exports.Jo=function linearDependencies(matrix,options={}){const{thresholdValue=1e-9,thresholdError=1e-9}=options;let n=(matrix=Matrix.checkMatrix(matrix)).rows,results=new Matrix(n,n);for(let i=0;i<n;i++){let b=Matrix.columnVector(matrix.getRow(i)),Abis=matrix.subMatrixRow(xrange(n,i)).transpose(),x=new SingularValueDecomposition(Abis).solve(b),error=Matrix.sub(b,Abis.mmul(x)).abs().max();results.setRow(i,dependenciesOneRow(error,x,i,thresholdValue,thresholdError))}return results},exports.Zi=function pseudoInverse(matrix,threshold=Number.EPSILON){if((matrix=Matrix.checkMatrix(matrix)).isEmpty())return matrix.transpose();let svdSolution=new SingularValueDecomposition(matrix,{autoTranspose:!0}),U=svdSolution.leftSingularVectors,V=svdSolution.rightSingularVectors,s=svdSolution.diagonal;for(let i=0;i<s.length;i++)Math.abs(s[i])>threshold?s[i]=1/s[i]:s[i]=0;return V.mmul(Matrix.diag(s).mmul(U.transpose()))},exports.kH=solve,exports.LV=function wrap(array,options){if(isAnyArray.isAnyArray(array))return array[0]&&isAnyArray.isAnyArray(array[0])?new WrapperMatrix2D(array):new WrapperMatrix1D(array,options);throw new Error("the argument is not an array")}},"./node_modules/ml-regression-polynomial/lib-esm/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Y:()=>PolynomialRegression});var matrix=__webpack_require__("./node_modules/ml-matrix/matrix.js");matrix.y3,matrix.jy,matrix.oN,matrix.Hc,matrix.cg,matrix.hj,matrix.LU,matrix.Tb;const Matrix=matrix.uq,MatrixTransposeView=(matrix.Zm,matrix.Dq,matrix.__,matrix.q0,matrix.lh,matrix.pI,matrix.zC,matrix.zg,matrix.g6),solve=(matrix.OL,matrix.ks,matrix.QR,matrix.jp,matrix.mk,matrix.W2,matrix.l,matrix.KY,matrix.dv,matrix.BR,matrix.Wu,matrix.Ay.Matrix?matrix.Ay.Matrix:matrix.uq,matrix.a4,matrix.DI,matrix.Jo,matrix.Zi,matrix.kH);matrix.LV;var lib_esm=__webpack_require__("./node_modules/is-any-array/lib-esm/index.js");function checkArrayLength(x,y){if(!(0,lib_esm.isAnyArray)(x)||!(0,lib_esm.isAnyArray)(y))throw new TypeError("x and y must be arrays");if(x.length!==y.length)throw new RangeError("x and y arrays must have the same length")}class BaseRegression{constructor(){if(new.target===BaseRegression)throw new Error("BaseRegression must be subclassed")}predict(x){if("number"==typeof x)return this._predict(x);if((0,lib_esm.isAnyArray)(x)){const y=[];for(const xVal of x)y.push(this._predict(xVal));return y}throw new TypeError("x must be a number or array")}_predict(x){throw new Error("_predict must be implemented")}train(){}toString(precision){return""}toLaTeX(precision){return""}score(x,y){checkArrayLength(x,y);const n=x.length,y2=new Array(n);for(let i=0;i<n;i++)y2[i]=this._predict(x[i]);let xSum=0,ySum=0,chi2=0,rmsd=0,xSquared=0,ySquared=0,xY=0;for(let i=0;i<n;i++)xSum+=y2[i],ySum+=y[i],xSquared+=y2[i]*y2[i],ySquared+=y[i]*y[i],xY+=y2[i]*y[i],0!==y[i]&&(chi2+=(y[i]-y2[i])*(y[i]-y2[i])/y[i]),rmsd+=(y[i]-y2[i])*(y[i]-y2[i]);const r=(n*xY-xSum*ySum)/Math.sqrt((n*xSquared-xSum*xSum)*(n*ySquared-ySum*ySum));return{r,r2:r*r,chi2,rmsd:Math.sqrt(rmsd/n)}}}function maybeToPrecision(number,figures){return number<0?(number=0-number,"number"==typeof figures?`- ${number.toPrecision(figures)}`:`- ${number.toString()}`):"number"==typeof figures?number.toPrecision(figures):number.toString()}class PolynomialRegression extends BaseRegression{constructor(x,y,degree,options={}){if(super(),!0===x)this.degree=y.degree,this.powers=y.powers,this.coefficients=y.coefficients;else{checkArrayLength(x,y);const result=function regress(x,y,degree,options={}){const n=x.length;let{interceptAtZero=!1}=options,powers=[];if(Array.isArray(degree))powers=degree,interceptAtZero=!1;else if("number"==typeof degree)if(interceptAtZero){powers=new Array(degree);for(let k=0;k<degree;k++)powers[k]=k+1}else{powers=new Array(degree+1);for(let k=0;k<=degree;k++)powers[k]=k}const nCoefficients=powers.length,F=new Matrix(n,nCoefficients),Y=new Matrix([y]);for(let k=0;k<nCoefficients;k++)for(let i=0;i<n;i++)0===powers[k]?F.set(i,k,1):F.set(i,k,x[i]**powers[k]);const FT=new MatrixTransposeView(F),A=FT.mmul(F),B=FT.mmul(new MatrixTransposeView(Y));return{coefficients:solve(A,B).to1DArray(),degree:Math.max(...powers),powers}}(x,y,degree,options);this.degree=result.degree,this.powers=result.powers,this.coefficients=result.coefficients}}_predict(x){let y=0;for(let k=0;k<this.powers.length;k++)y+=this.coefficients[k]*x**this.powers[k];return y}toJSON(){return{name:"polynomialRegression",degree:this.degree,powers:this.powers,coefficients:this.coefficients}}toString(precision){return this._toFormula(precision,!1)}toLaTeX(precision){return this._toFormula(precision,!0)}_toFormula(precision,isLaTeX){let sup="^",closeSup="",times=" * ";isLaTeX&&(sup="^{",closeSup="}",times="");let fn="",str="";for(let k=0;k<this.coefficients.length;k++)str="",0!==this.coefficients[k]&&(str=0===this.powers[k]?maybeToPrecision(this.coefficients[k],precision):1===this.powers[k]?`${maybeToPrecision(this.coefficients[k],precision)+times}x`:`${maybeToPrecision(this.coefficients[k],precision)+times}x${sup}${this.powers[k]}${closeSup}`,this.coefficients[k]>0&&k!==this.coefficients.length-1?str=` + ${str}`:k!==this.coefficients.length-1&&(str=` ${str}`)),fn=str+fn;return fn.startsWith("+")&&(fn=fn.slice(1)),`f(x) = ${fn}`}static load(json){if("polynomialRegression"!==json.name)throw new TypeError("not a polynomial regression model");return new PolynomialRegression(!0,json)}}}}]);